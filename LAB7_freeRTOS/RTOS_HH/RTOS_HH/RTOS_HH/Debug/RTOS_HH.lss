
RTOS_HH.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000036  00800200  000014a2  00001536  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000014a2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000618  00800236  00800236  0000156c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000156c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000159c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002e0  00000000  00000000  000015dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003848  00000000  00000000  000018bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000175b  00000000  00000000  00005104  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001b0b  00000000  00000000  0000685f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000714  00000000  00000000  0000836c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000011e0  00000000  00000000  00008a80  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000205b  00000000  00000000  00009c60  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000298  00000000  00000000  0000bcbb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c0       	rjmp	.+254    	; 0x124 <__bad_interrupt>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	67 c0       	rjmp	.+206    	; 0x124 <__bad_interrupt>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	5f c0       	rjmp	.+190    	; 0x124 <__bad_interrupt>
      66:	00 00       	nop
      68:	5d c0       	rjmp	.+186    	; 0x124 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	57 c0       	rjmp	.+174    	; 0x124 <__bad_interrupt>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	49 c0       	rjmp	.+146    	; 0x124 <__bad_interrupt>
      92:	00 00       	nop
      94:	47 c0       	rjmp	.+142    	; 0x124 <__bad_interrupt>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	8f c3       	rjmp	.+1822   	; 0x7dc <__vector_47>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e2 ea       	ldi	r30, 0xA2	; 162
      fc:	f4 e1       	ldi	r31, 0x14	; 20
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a6 33       	cpi	r26, 0x36	; 54
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	28 e0       	ldi	r18, 0x08	; 8
     110:	a6 e3       	ldi	r26, 0x36	; 54
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	ae 34       	cpi	r26, 0x4E	; 78
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0b d1       	rcall	.+534    	; 0x336 <main>
     120:	0c 94 4f 0a 	jmp	0x149e	; 0x149e <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <initLEDport>:
#define MAX_LED_NR 7

void initLEDport()
{
  // Sæt alle PORTB's ben til at være udgange
  DDRB = 0xFF;
     126:	8f ef       	ldi	r24, 0xFF	; 255
     128:	84 b9       	out	0x04, r24	; 4
  // Sluk alle lysdioderne
  PORTB = 0;
     12a:	15 b8       	out	0x05, r1	; 5
     12c:	08 95       	ret

0000012e <writeAllLEDs>:
}

void writeAllLEDs(unsigned char pattern)
{
  // Hent parameteren og skriv til lysdioderne
  PORTB = pattern;   
     12e:	85 b9       	out	0x05, r24	; 5
     130:	08 95       	ret

00000132 <initSwitchPort>:

// Læser alle switches samtidigt
unsigned char switchStatus()
{
  return (~PINA);
}
     132:	11 b8       	out	0x01, r1	; 1
     134:	08 95       	ret

00000136 <switchOn>:
// Returnerer TRUE, hvis switchen med nummeret
// "switch_nr" er aktiveret - ellers returneres FALSE
unsigned char switchOn(unsigned char switch_nr)
{
unsigned char mask;
  if (switch_nr <= MAX_SWITCH_NR)
     136:	88 30       	cpi	r24, 0x08	; 8
     138:	70 f4       	brcc	.+28     	; 0x156 <switchOn+0x20>
  {
    mask = 0b00000001 << switch_nr;
    return (~PINA & mask);
     13a:	90 b1       	in	r25, 0x00	; 0
     13c:	49 2f       	mov	r20, r25
     13e:	40 95       	com	r20
     140:	21 e0       	ldi	r18, 0x01	; 1
     142:	30 e0       	ldi	r19, 0x00	; 0
     144:	b9 01       	movw	r22, r18
     146:	02 c0       	rjmp	.+4      	; 0x14c <switchOn+0x16>
     148:	66 0f       	add	r22, r22
     14a:	77 1f       	adc	r23, r23
     14c:	8a 95       	dec	r24
     14e:	e2 f7       	brpl	.-8      	; 0x148 <switchOn+0x12>
     150:	cb 01       	movw	r24, r22
     152:	84 23       	and	r24, r20
     154:	08 95       	ret
  }
  else
    return 0;
     156:	80 e0       	ldi	r24, 0x00	; 0
     158:	08 95       	ret

0000015a <InitUART>:
  // Wait for new character received
  while ( (UCSR0A & (1<<7)) == 0 )
  {}                        
  // Then return it
  return UDR0;
}
     15a:	0f 93       	push	r16
     15c:	1f 93       	push	r17
     15e:	52 2f       	mov	r21, r18
     160:	8b 01       	movw	r16, r22
     162:	9c 01       	movw	r18, r24
     164:	0c 52       	subi	r16, 0x2C	; 44
     166:	11 40       	sbci	r17, 0x01	; 1
     168:	21 09       	sbc	r18, r1
     16a:	31 09       	sbc	r19, r1
     16c:	05 3d       	cpi	r16, 0xD5	; 213
     16e:	10 4c       	sbci	r17, 0xC0	; 192
     170:	21 40       	sbci	r18, 0x01	; 1
     172:	31 05       	cpc	r19, r1
     174:	d8 f5       	brcc	.+118    	; 0x1ec <InitUART+0x92>
     176:	45 50       	subi	r20, 0x05	; 5
     178:	44 30       	cpi	r20, 0x04	; 4
     17a:	c0 f5       	brcc	.+112    	; 0x1ec <InitUART+0x92>
     17c:	20 e2       	ldi	r18, 0x20	; 32
     17e:	20 93 c0 00 	sts	0x00C0, r18	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     182:	28 e1       	ldi	r18, 0x18	; 24
     184:	20 93 c1 00 	sts	0x00C1, r18	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     188:	44 0f       	add	r20, r20
     18a:	40 93 c2 00 	sts	0x00C2, r20	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     18e:	55 34       	cpi	r21, 0x45	; 69
     190:	31 f4       	brne	.+12     	; 0x19e <InitUART+0x44>
     192:	e2 ec       	ldi	r30, 0xC2	; 194
     194:	f0 e0       	ldi	r31, 0x00	; 0
     196:	20 81       	ld	r18, Z
     198:	20 62       	ori	r18, 0x20	; 32
     19a:	20 83       	st	Z, r18
     19c:	07 c0       	rjmp	.+14     	; 0x1ac <InitUART+0x52>
     19e:	5f 34       	cpi	r21, 0x4F	; 79
     1a0:	29 f4       	brne	.+10     	; 0x1ac <InitUART+0x52>
     1a2:	e2 ec       	ldi	r30, 0xC2	; 194
     1a4:	f0 e0       	ldi	r31, 0x00	; 0
     1a6:	20 81       	ld	r18, Z
     1a8:	20 63       	ori	r18, 0x30	; 48
     1aa:	20 83       	st	Z, r18
     1ac:	dc 01       	movw	r26, r24
     1ae:	cb 01       	movw	r24, r22
     1b0:	88 0f       	add	r24, r24
     1b2:	99 1f       	adc	r25, r25
     1b4:	aa 1f       	adc	r26, r26
     1b6:	bb 1f       	adc	r27, r27
     1b8:	88 0f       	add	r24, r24
     1ba:	99 1f       	adc	r25, r25
     1bc:	aa 1f       	adc	r26, r26
     1be:	bb 1f       	adc	r27, r27
     1c0:	9c 01       	movw	r18, r24
     1c2:	ad 01       	movw	r20, r26
     1c4:	22 0f       	add	r18, r18
     1c6:	33 1f       	adc	r19, r19
     1c8:	44 1f       	adc	r20, r20
     1ca:	55 1f       	adc	r21, r21
     1cc:	22 0f       	add	r18, r18
     1ce:	33 1f       	adc	r19, r19
     1d0:	44 1f       	adc	r20, r20
     1d2:	55 1f       	adc	r21, r21
     1d4:	60 e0       	ldi	r22, 0x00	; 0
     1d6:	74 e2       	ldi	r23, 0x24	; 36
     1d8:	84 ef       	ldi	r24, 0xF4	; 244
     1da:	90 e0       	ldi	r25, 0x00	; 0
     1dc:	0e 94 db 09 	call	0x13b6	; 0x13b6 <__udivmodsi4>
     1e0:	21 50       	subi	r18, 0x01	; 1
     1e2:	31 09       	sbc	r19, r1
     1e4:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     1e8:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     1ec:	1f 91       	pop	r17
     1ee:	0f 91       	pop	r16
     1f0:	08 95       	ret

000001f2 <SendChar>:
	Tegn : Character for sending. 
*************************************************************************/
void SendChar(char Tegn)
{
  // Wait for transmitter register empty (ready for new character)
  while ( (UCSR0A & (1<<5)) == 0 )
     1f2:	e0 ec       	ldi	r30, 0xC0	; 192
     1f4:	f0 e0       	ldi	r31, 0x00	; 0
     1f6:	90 81       	ld	r25, Z
     1f8:	95 ff       	sbrs	r25, 5
     1fa:	fd cf       	rjmp	.-6      	; 0x1f6 <SendChar+0x4>
  {}
  // Then send the character
  UDR0 = Tegn;
     1fc:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     200:	08 95       	ret

00000202 <SendString>:
Sends 0 terminated string.
Parameter:
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
     202:	cf 93       	push	r28
     204:	df 93       	push	r29
     206:	ec 01       	movw	r28, r24
  // Repeat until zero-termination
  while (*Streng != 0)
     208:	88 81       	ld	r24, Y
     20a:	88 23       	and	r24, r24
     20c:	29 f0       	breq	.+10     	; 0x218 <SendString+0x16>
     20e:	21 96       	adiw	r28, 0x01	; 1
  {
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
     210:	f0 df       	rcall	.-32     	; 0x1f2 <SendChar>
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
  // Repeat until zero-termination
  while (*Streng != 0)
     212:	89 91       	ld	r24, Y+
     214:	81 11       	cpse	r24, r1
     216:	fc cf       	rjmp	.-8      	; 0x210 <SendString+0xe>
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    // Advance the pointer one step
    Streng++;
  }
}
     218:	df 91       	pop	r29
     21a:	cf 91       	pop	r28
     21c:	08 95       	ret

0000021e <SendInteger>:
Makes use of the C standard library <stdlib.h>.
Parameter:
    Tal: The integer to be converted and sent. 
*************************************************************************/
void SendInteger(int Tal)
{
     21e:	cf 93       	push	r28
     220:	df 93       	push	r29
     222:	cd b7       	in	r28, 0x3d	; 61
     224:	de b7       	in	r29, 0x3e	; 62
     226:	27 97       	sbiw	r28, 0x07	; 7
     228:	0f b6       	in	r0, 0x3f	; 63
     22a:	f8 94       	cli
     22c:	de bf       	out	0x3e, r29	; 62
     22e:	0f be       	out	0x3f, r0	; 63
     230:	cd bf       	out	0x3d, r28	; 61
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     232:	4a e0       	ldi	r20, 0x0A	; 10
     234:	be 01       	movw	r22, r28
     236:	6f 5f       	subi	r22, 0xFF	; 255
     238:	7f 4f       	sbci	r23, 0xFF	; 255
     23a:	0e 94 1c 0a 	call	0x1438	; 0x1438 <__itoa_ncheck>
char array[7];
  // Convert the integer to an ASCII string (array), radix = 10 
  itoa(Tal, array, 10);
  // - then send the string
  SendString(array);
     23e:	ce 01       	movw	r24, r28
     240:	01 96       	adiw	r24, 0x01	; 1
     242:	df df       	rcall	.-66     	; 0x202 <SendString>
}
     244:	27 96       	adiw	r28, 0x07	; 7
     246:	0f b6       	in	r0, 0x3f	; 63
     248:	f8 94       	cli
     24a:	de bf       	out	0x3e, r29	; 62
     24c:	0f be       	out	0x3f, r0	; 63
     24e:	cd bf       	out	0x3d, r28	; 61
     250:	df 91       	pop	r29
     252:	cf 91       	pop	r28
     254:	08 95       	ret

00000256 <DecrementCountTask1>:

void DecrementCountTask1( void *pvParameters )
{
	while(1)
	{
		if(switchOn(0)>0){
     256:	80 e0       	ldi	r24, 0x00	; 0
     258:	6e df       	rcall	.-292    	; 0x136 <switchOn>
     25a:	88 23       	and	r24, r24
     25c:	e1 f3       	breq	.-8      	; 0x256 <DecrementCountTask1>
			xSemaphoreTake(xSemaphore1,1000);
     25e:	20 e0       	ldi	r18, 0x00	; 0
     260:	48 ee       	ldi	r20, 0xE8	; 232
     262:	53 e0       	ldi	r21, 0x03	; 3
     264:	60 e0       	ldi	r22, 0x00	; 0
     266:	70 e0       	ldi	r23, 0x00	; 0
     268:	80 91 37 02 	lds	r24, 0x0237	; 0x800237 <xSemaphore1>
     26c:	90 91 38 02 	lds	r25, 0x0238	; 0x800238 <xSemaphore1+0x1>
     270:	51 d4       	rcall	.+2210   	; 0xb14 <xQueueGenericReceive>
			if(counter>0)
     272:	80 91 36 02 	lds	r24, 0x0236	; 0x800236 <__data_end>
     276:	88 23       	and	r24, r24
     278:	19 f0       	breq	.+6      	; 0x280 <DecrementCountTask1+0x2a>
				counter--;
     27a:	81 50       	subi	r24, 0x01	; 1
     27c:	80 93 36 02 	sts	0x0236, r24	; 0x800236 <__data_end>
			xSemaphoreGive(xSemaphore1);
     280:	20 e0       	ldi	r18, 0x00	; 0
     282:	40 e0       	ldi	r20, 0x00	; 0
     284:	50 e0       	ldi	r21, 0x00	; 0
     286:	60 e0       	ldi	r22, 0x00	; 0
     288:	70 e0       	ldi	r23, 0x00	; 0
     28a:	80 91 37 02 	lds	r24, 0x0237	; 0x800237 <xSemaphore1>
     28e:	90 91 38 02 	lds	r25, 0x0238	; 0x800238 <xSemaphore1+0x1>
     292:	b4 d3       	rcall	.+1896   	; 0x9fc <xQueueGenericSend>
			xQueueSendToBack(xQueue1,&counter,1000);
     294:	20 e0       	ldi	r18, 0x00	; 0
     296:	48 ee       	ldi	r20, 0xE8	; 232
     298:	53 e0       	ldi	r21, 0x03	; 3
     29a:	66 e3       	ldi	r22, 0x36	; 54
     29c:	72 e0       	ldi	r23, 0x02	; 2
     29e:	80 91 4c 08 	lds	r24, 0x084C	; 0x80084c <xQueue1>
     2a2:	90 91 4d 08 	lds	r25, 0x084D	; 0x80084d <xQueue1+0x1>
			vTaskDelay(100);
     2a6:	aa d3       	rcall	.+1876   	; 0x9fc <xQueueGenericSend>
     2a8:	84 e6       	ldi	r24, 0x64	; 100
     2aa:	90 e0       	ldi	r25, 0x00	; 0
     2ac:	5d d7       	rcall	.+3770   	; 0x1168 <vTaskDelay>
     2ae:	d3 cf       	rjmp	.-90     	; 0x256 <DecrementCountTask1>

000002b0 <IncrementCountTask2>:

void IncrementCountTask2(void *pvParameters )
{
	while(1)
	{
		if(switchOn(1)>0){
     2b0:	81 e0       	ldi	r24, 0x01	; 1
     2b2:	41 df       	rcall	.-382    	; 0x136 <switchOn>
     2b4:	88 23       	and	r24, r24
     2b6:	e1 f3       	breq	.-8      	; 0x2b0 <IncrementCountTask2>
			xSemaphoreTake(xSemaphore1,1000);
     2b8:	20 e0       	ldi	r18, 0x00	; 0
     2ba:	48 ee       	ldi	r20, 0xE8	; 232
     2bc:	53 e0       	ldi	r21, 0x03	; 3
     2be:	60 e0       	ldi	r22, 0x00	; 0
     2c0:	70 e0       	ldi	r23, 0x00	; 0
     2c2:	80 91 37 02 	lds	r24, 0x0237	; 0x800237 <xSemaphore1>
     2c6:	90 91 38 02 	lds	r25, 0x0238	; 0x800238 <xSemaphore1+0x1>
     2ca:	24 d4       	rcall	.+2120   	; 0xb14 <xQueueGenericReceive>
			counter++;
     2cc:	80 91 36 02 	lds	r24, 0x0236	; 0x800236 <__data_end>
     2d0:	8f 5f       	subi	r24, 0xFF	; 255
     2d2:	80 93 36 02 	sts	0x0236, r24	; 0x800236 <__data_end>
			xSemaphoreGive(xSemaphore1);
     2d6:	20 e0       	ldi	r18, 0x00	; 0
     2d8:	40 e0       	ldi	r20, 0x00	; 0
     2da:	50 e0       	ldi	r21, 0x00	; 0
     2dc:	60 e0       	ldi	r22, 0x00	; 0
     2de:	70 e0       	ldi	r23, 0x00	; 0
     2e0:	80 91 37 02 	lds	r24, 0x0237	; 0x800237 <xSemaphore1>
     2e4:	90 91 38 02 	lds	r25, 0x0238	; 0x800238 <xSemaphore1+0x1>
     2e8:	89 d3       	rcall	.+1810   	; 0x9fc <xQueueGenericSend>
			xQueueSendToBack(xQueue1,&counter,1000);
     2ea:	20 e0       	ldi	r18, 0x00	; 0
     2ec:	48 ee       	ldi	r20, 0xE8	; 232
     2ee:	53 e0       	ldi	r21, 0x03	; 3
     2f0:	66 e3       	ldi	r22, 0x36	; 54
     2f2:	72 e0       	ldi	r23, 0x02	; 2
     2f4:	80 91 4c 08 	lds	r24, 0x084C	; 0x80084c <xQueue1>
     2f8:	90 91 4d 08 	lds	r25, 0x084D	; 0x80084d <xQueue1+0x1>
			vTaskDelay(100);
     2fc:	7f d3       	rcall	.+1790   	; 0x9fc <xQueueGenericSend>
     2fe:	84 e6       	ldi	r24, 0x64	; 100
     300:	90 e0       	ldi	r25, 0x00	; 0
     302:	32 d7       	rcall	.+3684   	; 0x1168 <vTaskDelay>
     304:	d5 cf       	rjmp	.-86     	; 0x2b0 <IncrementCountTask2>

00000306 <ConsumerTask3>:
		}
	}
}

void ConsumerTask3( void *pvParameters )
{
     306:	cf 93       	push	r28
     308:	df 93       	push	r29
     30a:	1f 92       	push	r1
     30c:	cd b7       	in	r28, 0x3d	; 61
     30e:	de b7       	in	r29, 0x3e	; 62
	unsigned char buffer;
	
	while(1)
	{
		if(xQueueReceive(xQueue1,&buffer,9999)>0)
     310:	20 e0       	ldi	r18, 0x00	; 0
     312:	4f e0       	ldi	r20, 0x0F	; 15
     314:	57 e2       	ldi	r21, 0x27	; 39
     316:	be 01       	movw	r22, r28
     318:	6f 5f       	subi	r22, 0xFF	; 255
     31a:	7f 4f       	sbci	r23, 0xFF	; 255
     31c:	80 91 4c 08 	lds	r24, 0x084C	; 0x80084c <xQueue1>
     320:	90 91 4d 08 	lds	r25, 0x084D	; 0x80084d <xQueue1+0x1>
     324:	f7 d3       	rcall	.+2030   	; 0xb14 <xQueueGenericReceive>
     326:	18 16       	cp	r1, r24
     328:	9c f7       	brge	.-26     	; 0x310 <ConsumerTask3+0xa>
		{
			writeAllLEDs(buffer);
     32a:	89 81       	ldd	r24, Y+1	; 0x01
     32c:	00 df       	rcall	.-512    	; 0x12e <writeAllLEDs>
			SendInteger(buffer);
     32e:	89 81       	ldd	r24, Y+1	; 0x01
     330:	90 e0       	ldi	r25, 0x00	; 0
     332:	75 df       	rcall	.-278    	; 0x21e <SendInteger>
     334:	ed cf       	rjmp	.-38     	; 0x310 <ConsumerTask3+0xa>

00000336 <main>:
	}
}

int main(void)
{
	initLEDport();
     336:	f7 de       	rcall	.-530    	; 0x126 <initLEDport>
	initSwitchPort();
     338:	fc de       	rcall	.-520    	; 0x132 <initSwitchPort>
     33a:	2e e4       	ldi	r18, 0x4E	; 78
	InitUART(9600,8,'N');
     33c:	48 e0       	ldi	r20, 0x08	; 8
     33e:	60 e8       	ldi	r22, 0x80	; 128
     340:	75 e2       	ldi	r23, 0x25	; 37
     342:	80 e0       	ldi	r24, 0x00	; 0
     344:	90 e0       	ldi	r25, 0x00	; 0
     346:	09 df       	rcall	.-494    	; 0x15a <InitUART>
     348:	82 e0       	ldi	r24, 0x02	; 2
	SendString("This is the start of main - Hello");
     34a:	92 e0       	ldi	r25, 0x02	; 2
     34c:	5a df       	rcall	.-332    	; 0x202 <SendString>
     34e:	43 e0       	ldi	r20, 0x03	; 3
	vSemaphoreCreateBinary(xSemaphore1);
     350:	60 e0       	ldi	r22, 0x00	; 0
     352:	81 e0       	ldi	r24, 0x01	; 1
     354:	08 d3       	rcall	.+1552   	; 0x966 <xQueueGenericCreate>
     356:	90 93 38 02 	sts	0x0238, r25	; 0x800238 <xSemaphore1+0x1>
     35a:	80 93 37 02 	sts	0x0237, r24	; 0x800237 <xSemaphore1>
     35e:	00 97       	sbiw	r24, 0x00	; 0
     360:	31 f0       	breq	.+12     	; 0x36e <main+0x38>
     362:	20 e0       	ldi	r18, 0x00	; 0
     364:	40 e0       	ldi	r20, 0x00	; 0
     366:	50 e0       	ldi	r21, 0x00	; 0
     368:	60 e0       	ldi	r22, 0x00	; 0
     36a:	70 e0       	ldi	r23, 0x00	; 0
     36c:	47 d3       	rcall	.+1678   	; 0x9fc <xQueueGenericSend>
     36e:	40 e0       	ldi	r20, 0x00	; 0
	xQueue1=xQueueCreate(10,sizeof(unsigned char));
     370:	61 e0       	ldi	r22, 0x01	; 1
     372:	8a e0       	ldi	r24, 0x0A	; 10
     374:	f8 d2       	rcall	.+1520   	; 0x966 <xQueueGenericCreate>
     376:	90 93 4d 08 	sts	0x084D, r25	; 0x80084d <xQueue1+0x1>
     37a:	80 93 4c 08 	sts	0x084C, r24	; 0x80084c <xQueue1>
     37e:	a1 2c       	mov	r10, r1
     380:	b1 2c       	mov	r11, r1
	xTaskCreate( DecrementCountTask1, ( signed char * ) "DEC", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     382:	c1 2c       	mov	r12, r1
     384:	d1 2c       	mov	r13, r1
     386:	e1 2c       	mov	r14, r1
     388:	f1 2c       	mov	r15, r1
     38a:	00 e0       	ldi	r16, 0x00	; 0
     38c:	20 e0       	ldi	r18, 0x00	; 0
     38e:	30 e0       	ldi	r19, 0x00	; 0
     390:	45 e5       	ldi	r20, 0x55	; 85
     392:	50 e0       	ldi	r21, 0x00	; 0
     394:	64 e2       	ldi	r22, 0x24	; 36
     396:	72 e0       	ldi	r23, 0x02	; 2
     398:	8b e2       	ldi	r24, 0x2B	; 43
     39a:	91 e0       	ldi	r25, 0x01	; 1
     39c:	93 d4       	rcall	.+2342   	; 0xcc4 <xTaskGenericCreate>
     39e:	20 e0       	ldi	r18, 0x00	; 0
     3a0:	30 e0       	ldi	r19, 0x00	; 0
	xTaskCreate( IncrementCountTask2, ( signed char * ) "INC", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     3a2:	45 e5       	ldi	r20, 0x55	; 85
     3a4:	50 e0       	ldi	r21, 0x00	; 0
     3a6:	68 e2       	ldi	r22, 0x28	; 40
     3a8:	72 e0       	ldi	r23, 0x02	; 2
     3aa:	88 e5       	ldi	r24, 0x58	; 88
     3ac:	91 e0       	ldi	r25, 0x01	; 1
     3ae:	8a d4       	rcall	.+2324   	; 0xcc4 <xTaskGenericCreate>
     3b0:	20 e0       	ldi	r18, 0x00	; 0
     3b2:	30 e0       	ldi	r19, 0x00	; 0
	xTaskCreate(ConsumerTask3,( signed char * ) "SW0", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     3b4:	45 e5       	ldi	r20, 0x55	; 85
     3b6:	50 e0       	ldi	r21, 0x00	; 0
     3b8:	6c e2       	ldi	r22, 0x2C	; 44
     3ba:	72 e0       	ldi	r23, 0x02	; 2
     3bc:	83 e8       	ldi	r24, 0x83	; 131
     3be:	91 e0       	ldi	r25, 0x01	; 1
     3c0:	81 d4       	rcall	.+2306   	; 0xcc4 <xTaskGenericCreate>
     3c2:	61 d5       	rcall	.+2754   	; 0xe86 <vTaskStartScheduler>
     3c4:	ff cf       	rjmp	.-2      	; 0x3c4 <main+0x8e>

000003c6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     3c6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     3c8:	03 96       	adiw	r24, 0x03	; 3
     3ca:	92 83       	std	Z+2, r25	; 0x02
     3cc:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     3ce:	2f ef       	ldi	r18, 0xFF	; 255
     3d0:	3f ef       	ldi	r19, 0xFF	; 255
     3d2:	34 83       	std	Z+4, r19	; 0x04
     3d4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     3d6:	96 83       	std	Z+6, r25	; 0x06
     3d8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     3da:	90 87       	std	Z+8, r25	; 0x08
     3dc:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     3de:	10 82       	st	Z, r1
     3e0:	08 95       	ret

000003e2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     3e2:	fc 01       	movw	r30, r24
     3e4:	11 86       	std	Z+9, r1	; 0x09
     3e6:	10 86       	std	Z+8, r1	; 0x08
     3e8:	08 95       	ret

000003ea <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     3ea:	cf 93       	push	r28
     3ec:	df 93       	push	r29
     3ee:	fc 01       	movw	r30, r24
     3f0:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     3f2:	21 81       	ldd	r18, Z+1	; 0x01
     3f4:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     3f6:	e9 01       	movw	r28, r18
     3f8:	8a 81       	ldd	r24, Y+2	; 0x02
     3fa:	9b 81       	ldd	r25, Y+3	; 0x03
     3fc:	13 96       	adiw	r26, 0x03	; 3
     3fe:	9c 93       	st	X, r25
     400:	8e 93       	st	-X, r24
     402:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     404:	81 81       	ldd	r24, Z+1	; 0x01
     406:	92 81       	ldd	r25, Z+2	; 0x02
     408:	15 96       	adiw	r26, 0x05	; 5
     40a:	9c 93       	st	X, r25
     40c:	8e 93       	st	-X, r24
     40e:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     410:	8a 81       	ldd	r24, Y+2	; 0x02
     412:	9b 81       	ldd	r25, Y+3	; 0x03
     414:	ec 01       	movw	r28, r24
     416:	7d 83       	std	Y+5, r23	; 0x05
     418:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     41a:	e9 01       	movw	r28, r18
     41c:	7b 83       	std	Y+3, r23	; 0x03
     41e:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     420:	72 83       	std	Z+2, r23	; 0x02
     422:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     424:	19 96       	adiw	r26, 0x09	; 9
     426:	fc 93       	st	X, r31
     428:	ee 93       	st	-X, r30
     42a:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     42c:	80 81       	ld	r24, Z
     42e:	8f 5f       	subi	r24, 0xFF	; 255
     430:	80 83       	st	Z, r24
}
     432:	df 91       	pop	r29
     434:	cf 91       	pop	r28
     436:	08 95       	ret

00000438 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     438:	cf 93       	push	r28
     43a:	df 93       	push	r29
     43c:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     43e:	48 81       	ld	r20, Y
     440:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     442:	4f 3f       	cpi	r20, 0xFF	; 255
     444:	2f ef       	ldi	r18, 0xFF	; 255
     446:	52 07       	cpc	r21, r18
     448:	31 f4       	brne	.+12     	; 0x456 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     44a:	dc 01       	movw	r26, r24
     44c:	17 96       	adiw	r26, 0x07	; 7
     44e:	ed 91       	ld	r30, X+
     450:	fc 91       	ld	r31, X
     452:	18 97       	sbiw	r26, 0x08	; 8
     454:	17 c0       	rjmp	.+46     	; 0x484 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     456:	fc 01       	movw	r30, r24
     458:	33 96       	adiw	r30, 0x03	; 3
     45a:	dc 01       	movw	r26, r24
     45c:	15 96       	adiw	r26, 0x05	; 5
     45e:	2d 91       	ld	r18, X+
     460:	3c 91       	ld	r19, X
     462:	16 97       	sbiw	r26, 0x06	; 6
     464:	d9 01       	movw	r26, r18
     466:	2d 91       	ld	r18, X+
     468:	3c 91       	ld	r19, X
     46a:	42 17       	cp	r20, r18
     46c:	53 07       	cpc	r21, r19
     46e:	50 f0       	brcs	.+20     	; 0x484 <vListInsert+0x4c>
     470:	02 80       	ldd	r0, Z+2	; 0x02
     472:	f3 81       	ldd	r31, Z+3	; 0x03
     474:	e0 2d       	mov	r30, r0
     476:	a2 81       	ldd	r26, Z+2	; 0x02
     478:	b3 81       	ldd	r27, Z+3	; 0x03
     47a:	2d 91       	ld	r18, X+
     47c:	3c 91       	ld	r19, X
     47e:	42 17       	cp	r20, r18
     480:	53 07       	cpc	r21, r19
     482:	b0 f7       	brcc	.-20     	; 0x470 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     484:	a2 81       	ldd	r26, Z+2	; 0x02
     486:	b3 81       	ldd	r27, Z+3	; 0x03
     488:	bb 83       	std	Y+3, r27	; 0x03
     48a:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     48c:	15 96       	adiw	r26, 0x05	; 5
     48e:	dc 93       	st	X, r29
     490:	ce 93       	st	-X, r28
     492:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     494:	fd 83       	std	Y+5, r31	; 0x05
     496:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     498:	d3 83       	std	Z+3, r29	; 0x03
     49a:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     49c:	99 87       	std	Y+9, r25	; 0x09
     49e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     4a0:	fc 01       	movw	r30, r24
     4a2:	20 81       	ld	r18, Z
     4a4:	2f 5f       	subi	r18, 0xFF	; 255
     4a6:	20 83       	st	Z, r18
}
     4a8:	df 91       	pop	r29
     4aa:	cf 91       	pop	r28
     4ac:	08 95       	ret

000004ae <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     4ae:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4b0:	a2 81       	ldd	r26, Z+2	; 0x02
     4b2:	b3 81       	ldd	r27, Z+3	; 0x03
     4b4:	84 81       	ldd	r24, Z+4	; 0x04
     4b6:	95 81       	ldd	r25, Z+5	; 0x05
     4b8:	15 96       	adiw	r26, 0x05	; 5
     4ba:	9c 93       	st	X, r25
     4bc:	8e 93       	st	-X, r24
     4be:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4c0:	a4 81       	ldd	r26, Z+4	; 0x04
     4c2:	b5 81       	ldd	r27, Z+5	; 0x05
     4c4:	82 81       	ldd	r24, Z+2	; 0x02
     4c6:	93 81       	ldd	r25, Z+3	; 0x03
     4c8:	13 96       	adiw	r26, 0x03	; 3
     4ca:	9c 93       	st	X, r25
     4cc:	8e 93       	st	-X, r24
     4ce:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     4d0:	a0 85       	ldd	r26, Z+8	; 0x08
     4d2:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     4d4:	11 96       	adiw	r26, 0x01	; 1
     4d6:	8d 91       	ld	r24, X+
     4d8:	9c 91       	ld	r25, X
     4da:	12 97       	sbiw	r26, 0x02	; 2
     4dc:	e8 17       	cp	r30, r24
     4de:	f9 07       	cpc	r31, r25
     4e0:	31 f4       	brne	.+12     	; 0x4ee <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     4e2:	84 81       	ldd	r24, Z+4	; 0x04
     4e4:	95 81       	ldd	r25, Z+5	; 0x05
     4e6:	12 96       	adiw	r26, 0x02	; 2
     4e8:	9c 93       	st	X, r25
     4ea:	8e 93       	st	-X, r24
     4ec:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     4ee:	11 86       	std	Z+9, r1	; 0x09
     4f0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     4f2:	8c 91       	ld	r24, X
     4f4:	81 50       	subi	r24, 0x01	; 1
     4f6:	8c 93       	st	X, r24
     4f8:	08 95       	ret

000004fa <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     4fa:	31 e1       	ldi	r19, 0x11	; 17
     4fc:	fc 01       	movw	r30, r24
     4fe:	30 83       	st	Z, r19
     500:	31 97       	sbiw	r30, 0x01	; 1
     502:	22 e2       	ldi	r18, 0x22	; 34
     504:	20 83       	st	Z, r18
     506:	31 97       	sbiw	r30, 0x01	; 1
     508:	a3 e3       	ldi	r26, 0x33	; 51
     50a:	a0 83       	st	Z, r26
     50c:	31 97       	sbiw	r30, 0x01	; 1
     50e:	60 83       	st	Z, r22
     510:	31 97       	sbiw	r30, 0x01	; 1
     512:	70 83       	st	Z, r23
     514:	31 97       	sbiw	r30, 0x01	; 1
     516:	10 82       	st	Z, r1
     518:	31 97       	sbiw	r30, 0x01	; 1
     51a:	10 82       	st	Z, r1
     51c:	31 97       	sbiw	r30, 0x01	; 1
     51e:	60 e8       	ldi	r22, 0x80	; 128
     520:	60 83       	st	Z, r22
     522:	31 97       	sbiw	r30, 0x01	; 1
     524:	10 82       	st	Z, r1
     526:	31 97       	sbiw	r30, 0x01	; 1
     528:	10 82       	st	Z, r1
     52a:	31 97       	sbiw	r30, 0x01	; 1
     52c:	10 82       	st	Z, r1
     52e:	31 97       	sbiw	r30, 0x01	; 1
     530:	62 e0       	ldi	r22, 0x02	; 2
     532:	60 83       	st	Z, r22
     534:	31 97       	sbiw	r30, 0x01	; 1
     536:	63 e0       	ldi	r22, 0x03	; 3
     538:	60 83       	st	Z, r22
     53a:	31 97       	sbiw	r30, 0x01	; 1
     53c:	64 e0       	ldi	r22, 0x04	; 4
     53e:	60 83       	st	Z, r22
     540:	31 97       	sbiw	r30, 0x01	; 1
     542:	65 e0       	ldi	r22, 0x05	; 5
     544:	60 83       	st	Z, r22
     546:	31 97       	sbiw	r30, 0x01	; 1
     548:	66 e0       	ldi	r22, 0x06	; 6
     54a:	60 83       	st	Z, r22
     54c:	31 97       	sbiw	r30, 0x01	; 1
     54e:	67 e0       	ldi	r22, 0x07	; 7
     550:	60 83       	st	Z, r22
     552:	31 97       	sbiw	r30, 0x01	; 1
     554:	68 e0       	ldi	r22, 0x08	; 8
     556:	60 83       	st	Z, r22
     558:	31 97       	sbiw	r30, 0x01	; 1
     55a:	69 e0       	ldi	r22, 0x09	; 9
     55c:	60 83       	st	Z, r22
     55e:	31 97       	sbiw	r30, 0x01	; 1
     560:	60 e1       	ldi	r22, 0x10	; 16
     562:	60 83       	st	Z, r22
     564:	31 97       	sbiw	r30, 0x01	; 1
     566:	30 83       	st	Z, r19
     568:	31 97       	sbiw	r30, 0x01	; 1
     56a:	32 e1       	ldi	r19, 0x12	; 18
     56c:	30 83       	st	Z, r19
     56e:	31 97       	sbiw	r30, 0x01	; 1
     570:	33 e1       	ldi	r19, 0x13	; 19
     572:	30 83       	st	Z, r19
     574:	31 97       	sbiw	r30, 0x01	; 1
     576:	34 e1       	ldi	r19, 0x14	; 20
     578:	30 83       	st	Z, r19
     57a:	31 97       	sbiw	r30, 0x01	; 1
     57c:	35 e1       	ldi	r19, 0x15	; 21
     57e:	30 83       	st	Z, r19
     580:	31 97       	sbiw	r30, 0x01	; 1
     582:	36 e1       	ldi	r19, 0x16	; 22
     584:	30 83       	st	Z, r19
     586:	31 97       	sbiw	r30, 0x01	; 1
     588:	37 e1       	ldi	r19, 0x17	; 23
     58a:	30 83       	st	Z, r19
     58c:	31 97       	sbiw	r30, 0x01	; 1
     58e:	38 e1       	ldi	r19, 0x18	; 24
     590:	30 83       	st	Z, r19
     592:	31 97       	sbiw	r30, 0x01	; 1
     594:	39 e1       	ldi	r19, 0x19	; 25
     596:	30 83       	st	Z, r19
     598:	31 97       	sbiw	r30, 0x01	; 1
     59a:	30 e2       	ldi	r19, 0x20	; 32
     59c:	30 83       	st	Z, r19
     59e:	31 97       	sbiw	r30, 0x01	; 1
     5a0:	31 e2       	ldi	r19, 0x21	; 33
     5a2:	30 83       	st	Z, r19
     5a4:	31 97       	sbiw	r30, 0x01	; 1
     5a6:	20 83       	st	Z, r18
     5a8:	31 97       	sbiw	r30, 0x01	; 1
     5aa:	23 e2       	ldi	r18, 0x23	; 35
     5ac:	20 83       	st	Z, r18
     5ae:	31 97       	sbiw	r30, 0x01	; 1
     5b0:	40 83       	st	Z, r20
     5b2:	31 97       	sbiw	r30, 0x01	; 1
     5b4:	50 83       	st	Z, r21
     5b6:	31 97       	sbiw	r30, 0x01	; 1
     5b8:	26 e2       	ldi	r18, 0x26	; 38
     5ba:	20 83       	st	Z, r18
     5bc:	31 97       	sbiw	r30, 0x01	; 1
     5be:	27 e2       	ldi	r18, 0x27	; 39
     5c0:	20 83       	st	Z, r18
     5c2:	31 97       	sbiw	r30, 0x01	; 1
     5c4:	28 e2       	ldi	r18, 0x28	; 40
     5c6:	20 83       	st	Z, r18
     5c8:	31 97       	sbiw	r30, 0x01	; 1
     5ca:	29 e2       	ldi	r18, 0x29	; 41
     5cc:	20 83       	st	Z, r18
     5ce:	31 97       	sbiw	r30, 0x01	; 1
     5d0:	20 e3       	ldi	r18, 0x30	; 48
     5d2:	20 83       	st	Z, r18
     5d4:	31 97       	sbiw	r30, 0x01	; 1
     5d6:	21 e3       	ldi	r18, 0x31	; 49
     5d8:	20 83       	st	Z, r18
     5da:	89 97       	sbiw	r24, 0x29	; 41
     5dc:	08 95       	ret

000005de <xPortStartScheduler>:
     5de:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
     5e2:	89 ef       	ldi	r24, 0xF9	; 249
     5e4:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
     5e8:	8b e0       	ldi	r24, 0x0B	; 11
     5ea:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
     5ee:	e3 e7       	ldi	r30, 0x73	; 115
     5f0:	f0 e0       	ldi	r31, 0x00	; 0
     5f2:	80 81       	ld	r24, Z
     5f4:	82 60       	ori	r24, 0x02	; 2
     5f6:	80 83       	st	Z, r24
     5f8:	a0 91 4a 08 	lds	r26, 0x084A	; 0x80084a <pxCurrentTCB>
     5fc:	b0 91 4b 08 	lds	r27, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
     600:	cd 91       	ld	r28, X+
     602:	cd bf       	out	0x3d, r28	; 61
     604:	dd 91       	ld	r29, X+
     606:	de bf       	out	0x3e, r29	; 62
     608:	ff 91       	pop	r31
     60a:	ef 91       	pop	r30
     60c:	df 91       	pop	r29
     60e:	cf 91       	pop	r28
     610:	bf 91       	pop	r27
     612:	af 91       	pop	r26
     614:	9f 91       	pop	r25
     616:	8f 91       	pop	r24
     618:	7f 91       	pop	r23
     61a:	6f 91       	pop	r22
     61c:	5f 91       	pop	r21
     61e:	4f 91       	pop	r20
     620:	3f 91       	pop	r19
     622:	2f 91       	pop	r18
     624:	1f 91       	pop	r17
     626:	0f 91       	pop	r16
     628:	ff 90       	pop	r15
     62a:	ef 90       	pop	r14
     62c:	df 90       	pop	r13
     62e:	cf 90       	pop	r12
     630:	bf 90       	pop	r11
     632:	af 90       	pop	r10
     634:	9f 90       	pop	r9
     636:	8f 90       	pop	r8
     638:	7f 90       	pop	r7
     63a:	6f 90       	pop	r6
     63c:	5f 90       	pop	r5
     63e:	4f 90       	pop	r4
     640:	3f 90       	pop	r3
     642:	2f 90       	pop	r2
     644:	1f 90       	pop	r1
     646:	0f 90       	pop	r0
     648:	0c be       	out	0x3c, r0	; 60
     64a:	0f 90       	pop	r0
     64c:	0b be       	out	0x3b, r0	; 59
     64e:	0f 90       	pop	r0
     650:	0f be       	out	0x3f, r0	; 63
     652:	0f 90       	pop	r0
     654:	08 95       	ret
     656:	81 e0       	ldi	r24, 0x01	; 1
     658:	08 95       	ret

0000065a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     65a:	0f 92       	push	r0
     65c:	0f b6       	in	r0, 0x3f	; 63
     65e:	f8 94       	cli
     660:	0f 92       	push	r0
     662:	0b b6       	in	r0, 0x3b	; 59
     664:	0f 92       	push	r0
     666:	0c b6       	in	r0, 0x3c	; 60
     668:	0f 92       	push	r0
     66a:	1f 92       	push	r1
     66c:	11 24       	eor	r1, r1
     66e:	2f 92       	push	r2
     670:	3f 92       	push	r3
     672:	4f 92       	push	r4
     674:	5f 92       	push	r5
     676:	6f 92       	push	r6
     678:	7f 92       	push	r7
     67a:	8f 92       	push	r8
     67c:	9f 92       	push	r9
     67e:	af 92       	push	r10
     680:	bf 92       	push	r11
     682:	cf 92       	push	r12
     684:	df 92       	push	r13
     686:	ef 92       	push	r14
     688:	ff 92       	push	r15
     68a:	0f 93       	push	r16
     68c:	1f 93       	push	r17
     68e:	2f 93       	push	r18
     690:	3f 93       	push	r19
     692:	4f 93       	push	r20
     694:	5f 93       	push	r21
     696:	6f 93       	push	r22
     698:	7f 93       	push	r23
     69a:	8f 93       	push	r24
     69c:	9f 93       	push	r25
     69e:	af 93       	push	r26
     6a0:	bf 93       	push	r27
     6a2:	cf 93       	push	r28
     6a4:	df 93       	push	r29
     6a6:	ef 93       	push	r30
     6a8:	ff 93       	push	r31
     6aa:	a0 91 4a 08 	lds	r26, 0x084A	; 0x80084a <pxCurrentTCB>
     6ae:	b0 91 4b 08 	lds	r27, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
     6b2:	0d b6       	in	r0, 0x3d	; 61
     6b4:	0d 92       	st	X+, r0
     6b6:	0e b6       	in	r0, 0x3e	; 62
     6b8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     6ba:	71 d5       	rcall	.+2786   	; 0x119e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     6bc:	a0 91 4a 08 	lds	r26, 0x084A	; 0x80084a <pxCurrentTCB>
     6c0:	b0 91 4b 08 	lds	r27, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
     6c4:	cd 91       	ld	r28, X+
     6c6:	cd bf       	out	0x3d, r28	; 61
     6c8:	dd 91       	ld	r29, X+
     6ca:	de bf       	out	0x3e, r29	; 62
     6cc:	ff 91       	pop	r31
     6ce:	ef 91       	pop	r30
     6d0:	df 91       	pop	r29
     6d2:	cf 91       	pop	r28
     6d4:	bf 91       	pop	r27
     6d6:	af 91       	pop	r26
     6d8:	9f 91       	pop	r25
     6da:	8f 91       	pop	r24
     6dc:	7f 91       	pop	r23
     6de:	6f 91       	pop	r22
     6e0:	5f 91       	pop	r21
     6e2:	4f 91       	pop	r20
     6e4:	3f 91       	pop	r19
     6e6:	2f 91       	pop	r18
     6e8:	1f 91       	pop	r17
     6ea:	0f 91       	pop	r16
     6ec:	ff 90       	pop	r15
     6ee:	ef 90       	pop	r14
     6f0:	df 90       	pop	r13
     6f2:	cf 90       	pop	r12
     6f4:	bf 90       	pop	r11
     6f6:	af 90       	pop	r10
     6f8:	9f 90       	pop	r9
     6fa:	8f 90       	pop	r8
     6fc:	7f 90       	pop	r7
     6fe:	6f 90       	pop	r6
     700:	5f 90       	pop	r5
     702:	4f 90       	pop	r4
     704:	3f 90       	pop	r3
     706:	2f 90       	pop	r2
     708:	1f 90       	pop	r1
     70a:	0f 90       	pop	r0
     70c:	0c be       	out	0x3c, r0	; 60
     70e:	0f 90       	pop	r0
     710:	0b be       	out	0x3b, r0	; 59
     712:	0f 90       	pop	r0
     714:	0f be       	out	0x3f, r0	; 63
     716:	0f 90       	pop	r0

	asm volatile ( "ret" );
     718:	08 95       	ret

0000071a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     71a:	0f 92       	push	r0
     71c:	0f b6       	in	r0, 0x3f	; 63
     71e:	f8 94       	cli
     720:	0f 92       	push	r0
     722:	0b b6       	in	r0, 0x3b	; 59
     724:	0f 92       	push	r0
     726:	0c b6       	in	r0, 0x3c	; 60
     728:	0f 92       	push	r0
     72a:	1f 92       	push	r1
     72c:	11 24       	eor	r1, r1
     72e:	2f 92       	push	r2
     730:	3f 92       	push	r3
     732:	4f 92       	push	r4
     734:	5f 92       	push	r5
     736:	6f 92       	push	r6
     738:	7f 92       	push	r7
     73a:	8f 92       	push	r8
     73c:	9f 92       	push	r9
     73e:	af 92       	push	r10
     740:	bf 92       	push	r11
     742:	cf 92       	push	r12
     744:	df 92       	push	r13
     746:	ef 92       	push	r14
     748:	ff 92       	push	r15
     74a:	0f 93       	push	r16
     74c:	1f 93       	push	r17
     74e:	2f 93       	push	r18
     750:	3f 93       	push	r19
     752:	4f 93       	push	r20
     754:	5f 93       	push	r21
     756:	6f 93       	push	r22
     758:	7f 93       	push	r23
     75a:	8f 93       	push	r24
     75c:	9f 93       	push	r25
     75e:	af 93       	push	r26
     760:	bf 93       	push	r27
     762:	cf 93       	push	r28
     764:	df 93       	push	r29
     766:	ef 93       	push	r30
     768:	ff 93       	push	r31
     76a:	a0 91 4a 08 	lds	r26, 0x084A	; 0x80084a <pxCurrentTCB>
     76e:	b0 91 4b 08 	lds	r27, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
     772:	0d b6       	in	r0, 0x3d	; 61
     774:	0d 92       	st	X+, r0
     776:	0e b6       	in	r0, 0x3e	; 62
     778:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     77a:	b4 d3       	rcall	.+1896   	; 0xee4 <vTaskIncrementTick>
	vTaskSwitchContext();
     77c:	10 d5       	rcall	.+2592   	; 0x119e <vTaskSwitchContext>
     77e:	a0 91 4a 08 	lds	r26, 0x084A	; 0x80084a <pxCurrentTCB>
	portRESTORE_CONTEXT();
     782:	b0 91 4b 08 	lds	r27, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
     786:	cd 91       	ld	r28, X+
     788:	cd bf       	out	0x3d, r28	; 61
     78a:	dd 91       	ld	r29, X+
     78c:	de bf       	out	0x3e, r29	; 62
     78e:	ff 91       	pop	r31
     790:	ef 91       	pop	r30
     792:	df 91       	pop	r29
     794:	cf 91       	pop	r28
     796:	bf 91       	pop	r27
     798:	af 91       	pop	r26
     79a:	9f 91       	pop	r25
     79c:	8f 91       	pop	r24
     79e:	7f 91       	pop	r23
     7a0:	6f 91       	pop	r22
     7a2:	5f 91       	pop	r21
     7a4:	4f 91       	pop	r20
     7a6:	3f 91       	pop	r19
     7a8:	2f 91       	pop	r18
     7aa:	1f 91       	pop	r17
     7ac:	0f 91       	pop	r16
     7ae:	ff 90       	pop	r15
     7b0:	ef 90       	pop	r14
     7b2:	df 90       	pop	r13
     7b4:	cf 90       	pop	r12
     7b6:	bf 90       	pop	r11
     7b8:	af 90       	pop	r10
     7ba:	9f 90       	pop	r9
     7bc:	8f 90       	pop	r8
     7be:	7f 90       	pop	r7
     7c0:	6f 90       	pop	r6
     7c2:	5f 90       	pop	r5
     7c4:	4f 90       	pop	r4
     7c6:	3f 90       	pop	r3
     7c8:	2f 90       	pop	r2
     7ca:	1f 90       	pop	r1
     7cc:	0f 90       	pop	r0
     7ce:	0c be       	out	0x3c, r0	; 60
     7d0:	0f 90       	pop	r0
     7d2:	0b be       	out	0x3b, r0	; 59
     7d4:	0f 90       	pop	r0
     7d6:	0f be       	out	0x3f, r0	; 63
     7d8:	0f 90       	pop	r0
     7da:	08 95       	ret

000007dc <__vector_47>:
	asm volatile ( "ret" );
     7dc:	9e df       	rcall	.-196    	; 0x71a <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER5_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER5_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
     7de:	18 95       	reti

000007e0 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     7e0:	cf 93       	push	r28
     7e2:	df 93       	push	r29
     7e4:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     7e6:	78 d3       	rcall	.+1776   	; 0xed8 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     7e8:	20 91 39 02 	lds	r18, 0x0239	; 0x800239 <xNextFreeByte>
     7ec:	30 91 3a 02 	lds	r19, 0x023A	; 0x80023a <xNextFreeByte+0x1>
     7f0:	c9 01       	movw	r24, r18
     7f2:	8c 0f       	add	r24, r28
     7f4:	9d 1f       	adc	r25, r29
     7f6:	8c 3d       	cpi	r24, 0xDC	; 220
     7f8:	45 e0       	ldi	r20, 0x05	; 5
     7fa:	94 07       	cpc	r25, r20
     7fc:	58 f4       	brcc	.+22     	; 0x814 <pvPortMalloc+0x34>
     7fe:	28 17       	cp	r18, r24
     800:	39 07       	cpc	r19, r25
     802:	58 f4       	brcc	.+22     	; 0x81a <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     804:	e9 01       	movw	r28, r18
     806:	c5 5c       	subi	r28, 0xC5	; 197
     808:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
     80a:	90 93 3a 02 	sts	0x023A, r25	; 0x80023a <xNextFreeByte+0x1>
     80e:	80 93 39 02 	sts	0x0239, r24	; 0x800239 <xNextFreeByte>
     812:	05 c0       	rjmp	.+10     	; 0x81e <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     814:	c0 e0       	ldi	r28, 0x00	; 0
     816:	d0 e0       	ldi	r29, 0x00	; 0
     818:	02 c0       	rjmp	.+4      	; 0x81e <pvPortMalloc+0x3e>
     81a:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     81c:	d0 e0       	ldi	r29, 0x00	; 0
     81e:	23 d4       	rcall	.+2118   	; 0x1066 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     820:	ce 01       	movw	r24, r28
     822:	df 91       	pop	r29
     824:	cf 91       	pop	r28
     826:	08 95       	ret

00000828 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     828:	08 95       	ret

0000082a <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     82a:	cf 93       	push	r28
     82c:	df 93       	push	r29
     82e:	ec 01       	movw	r28, r24
     830:	8c 8d       	ldd	r24, Y+28	; 0x1c
     832:	88 23       	and	r24, r24
     834:	99 f1       	breq	.+102    	; 0x89c <prvCopyDataToQueue+0x72>
     836:	41 11       	cpse	r20, r1
     838:	16 c0       	rjmp	.+44     	; 0x866 <prvCopyDataToQueue+0x3c>
     83a:	48 2f       	mov	r20, r24
     83c:	50 e0       	ldi	r21, 0x00	; 0
     83e:	8c 81       	ldd	r24, Y+4	; 0x04
     840:	9d 81       	ldd	r25, Y+5	; 0x05
     842:	db d5       	rcall	.+2998   	; 0x13fa <memcpy>
     844:	2c 8d       	ldd	r18, Y+28	; 0x1c
     846:	8c 81       	ldd	r24, Y+4	; 0x04
     848:	9d 81       	ldd	r25, Y+5	; 0x05
     84a:	82 0f       	add	r24, r18
     84c:	91 1d       	adc	r25, r1
     84e:	9d 83       	std	Y+5, r25	; 0x05
     850:	8c 83       	std	Y+4, r24	; 0x04
     852:	2a 81       	ldd	r18, Y+2	; 0x02
     854:	3b 81       	ldd	r19, Y+3	; 0x03
     856:	82 17       	cp	r24, r18
     858:	93 07       	cpc	r25, r19
     85a:	00 f1       	brcs	.+64     	; 0x89c <prvCopyDataToQueue+0x72>
     85c:	88 81       	ld	r24, Y
     85e:	99 81       	ldd	r25, Y+1	; 0x01
     860:	9d 83       	std	Y+5, r25	; 0x05
     862:	8c 83       	std	Y+4, r24	; 0x04
     864:	1b c0       	rjmp	.+54     	; 0x89c <prvCopyDataToQueue+0x72>
     866:	48 2f       	mov	r20, r24
     868:	50 e0       	ldi	r21, 0x00	; 0
     86a:	8e 81       	ldd	r24, Y+6	; 0x06
     86c:	9f 81       	ldd	r25, Y+7	; 0x07
     86e:	c5 d5       	rcall	.+2954   	; 0x13fa <memcpy>
     870:	8c 8d       	ldd	r24, Y+28	; 0x1c
     872:	90 e0       	ldi	r25, 0x00	; 0
     874:	91 95       	neg	r25
     876:	81 95       	neg	r24
     878:	91 09       	sbc	r25, r1
     87a:	2e 81       	ldd	r18, Y+6	; 0x06
     87c:	3f 81       	ldd	r19, Y+7	; 0x07
     87e:	28 0f       	add	r18, r24
     880:	39 1f       	adc	r19, r25
     882:	3f 83       	std	Y+7, r19	; 0x07
     884:	2e 83       	std	Y+6, r18	; 0x06
     886:	48 81       	ld	r20, Y
     888:	59 81       	ldd	r21, Y+1	; 0x01
     88a:	24 17       	cp	r18, r20
     88c:	35 07       	cpc	r19, r21
     88e:	30 f4       	brcc	.+12     	; 0x89c <prvCopyDataToQueue+0x72>
     890:	2a 81       	ldd	r18, Y+2	; 0x02
     892:	3b 81       	ldd	r19, Y+3	; 0x03
     894:	82 0f       	add	r24, r18
     896:	93 1f       	adc	r25, r19
     898:	9f 83       	std	Y+7, r25	; 0x07
     89a:	8e 83       	std	Y+6, r24	; 0x06
     89c:	8a 8d       	ldd	r24, Y+26	; 0x1a
     89e:	8f 5f       	subi	r24, 0xFF	; 255
     8a0:	8a 8f       	std	Y+26, r24	; 0x1a
     8a2:	df 91       	pop	r29
     8a4:	cf 91       	pop	r28
     8a6:	08 95       	ret

000008a8 <prvCopyDataFromQueue>:
     8a8:	fc 01       	movw	r30, r24
     8aa:	80 81       	ld	r24, Z
     8ac:	91 81       	ldd	r25, Z+1	; 0x01
     8ae:	00 97       	sbiw	r24, 0x00	; 0
     8b0:	99 f0       	breq	.+38     	; 0x8d8 <prvCopyDataFromQueue+0x30>
     8b2:	44 8d       	ldd	r20, Z+28	; 0x1c
     8b4:	50 e0       	ldi	r21, 0x00	; 0
     8b6:	26 81       	ldd	r18, Z+6	; 0x06
     8b8:	37 81       	ldd	r19, Z+7	; 0x07
     8ba:	24 0f       	add	r18, r20
     8bc:	35 1f       	adc	r19, r21
     8be:	37 83       	std	Z+7, r19	; 0x07
     8c0:	26 83       	std	Z+6, r18	; 0x06
     8c2:	a2 81       	ldd	r26, Z+2	; 0x02
     8c4:	b3 81       	ldd	r27, Z+3	; 0x03
     8c6:	2a 17       	cp	r18, r26
     8c8:	3b 07       	cpc	r19, r27
     8ca:	10 f0       	brcs	.+4      	; 0x8d0 <prvCopyDataFromQueue+0x28>
     8cc:	97 83       	std	Z+7, r25	; 0x07
     8ce:	86 83       	std	Z+6, r24	; 0x06
     8d0:	cb 01       	movw	r24, r22
     8d2:	66 81       	ldd	r22, Z+6	; 0x06
     8d4:	77 81       	ldd	r23, Z+7	; 0x07
     8d6:	91 c5       	rjmp	.+2850   	; 0x13fa <memcpy>
     8d8:	08 95       	ret

000008da <prvUnlockQueue>:
     8da:	0f 93       	push	r16
     8dc:	1f 93       	push	r17
     8de:	cf 93       	push	r28
     8e0:	df 93       	push	r29
     8e2:	ec 01       	movw	r28, r24
     8e4:	0f b6       	in	r0, 0x3f	; 63
     8e6:	f8 94       	cli
     8e8:	0f 92       	push	r0
     8ea:	8e 8d       	ldd	r24, Y+30	; 0x1e
     8ec:	18 16       	cp	r1, r24
     8ee:	a4 f4       	brge	.+40     	; 0x918 <prvUnlockQueue+0x3e>
     8f0:	89 89       	ldd	r24, Y+17	; 0x11
     8f2:	81 11       	cpse	r24, r1
     8f4:	05 c0       	rjmp	.+10     	; 0x900 <prvUnlockQueue+0x26>
     8f6:	10 c0       	rjmp	.+32     	; 0x918 <prvUnlockQueue+0x3e>
     8f8:	89 89       	ldd	r24, Y+17	; 0x11
     8fa:	81 11       	cpse	r24, r1
     8fc:	04 c0       	rjmp	.+8      	; 0x906 <prvUnlockQueue+0x2c>
     8fe:	0c c0       	rjmp	.+24     	; 0x918 <prvUnlockQueue+0x3e>
     900:	8e 01       	movw	r16, r28
     902:	0f 5e       	subi	r16, 0xEF	; 239
     904:	1f 4f       	sbci	r17, 0xFF	; 255
     906:	c8 01       	movw	r24, r16
     908:	d0 d4       	rcall	.+2464   	; 0x12aa <xTaskRemoveFromEventList>
     90a:	81 11       	cpse	r24, r1
     90c:	50 d5       	rcall	.+2720   	; 0x13ae <vTaskMissedYield>
     90e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     910:	81 50       	subi	r24, 0x01	; 1
     912:	8e 8f       	std	Y+30, r24	; 0x1e
     914:	18 16       	cp	r1, r24
     916:	84 f3       	brlt	.-32     	; 0x8f8 <prvUnlockQueue+0x1e>
     918:	8f ef       	ldi	r24, 0xFF	; 255
     91a:	8e 8f       	std	Y+30, r24	; 0x1e
     91c:	0f 90       	pop	r0
     91e:	0f be       	out	0x3f, r0	; 63
     920:	0f b6       	in	r0, 0x3f	; 63
     922:	f8 94       	cli
     924:	0f 92       	push	r0
     926:	8d 8d       	ldd	r24, Y+29	; 0x1d
     928:	18 16       	cp	r1, r24
     92a:	a4 f4       	brge	.+40     	; 0x954 <prvUnlockQueue+0x7a>
     92c:	88 85       	ldd	r24, Y+8	; 0x08
     92e:	81 11       	cpse	r24, r1
     930:	05 c0       	rjmp	.+10     	; 0x93c <prvUnlockQueue+0x62>
     932:	10 c0       	rjmp	.+32     	; 0x954 <prvUnlockQueue+0x7a>
     934:	88 85       	ldd	r24, Y+8	; 0x08
     936:	81 11       	cpse	r24, r1
     938:	04 c0       	rjmp	.+8      	; 0x942 <prvUnlockQueue+0x68>
     93a:	0c c0       	rjmp	.+24     	; 0x954 <prvUnlockQueue+0x7a>
     93c:	8e 01       	movw	r16, r28
     93e:	08 5f       	subi	r16, 0xF8	; 248
     940:	1f 4f       	sbci	r17, 0xFF	; 255
     942:	c8 01       	movw	r24, r16
     944:	b2 d4       	rcall	.+2404   	; 0x12aa <xTaskRemoveFromEventList>
     946:	81 11       	cpse	r24, r1
     948:	32 d5       	rcall	.+2660   	; 0x13ae <vTaskMissedYield>
     94a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     94c:	81 50       	subi	r24, 0x01	; 1
     94e:	8d 8f       	std	Y+29, r24	; 0x1d
     950:	18 16       	cp	r1, r24
     952:	84 f3       	brlt	.-32     	; 0x934 <prvUnlockQueue+0x5a>
     954:	8f ef       	ldi	r24, 0xFF	; 255
     956:	8d 8f       	std	Y+29, r24	; 0x1d
     958:	0f 90       	pop	r0
     95a:	0f be       	out	0x3f, r0	; 63
     95c:	df 91       	pop	r29
     95e:	cf 91       	pop	r28
     960:	1f 91       	pop	r17
     962:	0f 91       	pop	r16
     964:	08 95       	ret

00000966 <xQueueGenericCreate>:
     966:	cf 92       	push	r12
     968:	df 92       	push	r13
     96a:	ef 92       	push	r14
     96c:	ff 92       	push	r15
     96e:	0f 93       	push	r16
     970:	1f 93       	push	r17
     972:	cf 93       	push	r28
     974:	df 93       	push	r29
     976:	88 23       	and	r24, r24
     978:	a9 f1       	breq	.+106    	; 0x9e4 <xQueueGenericCreate+0x7e>
     97a:	e6 2e       	mov	r14, r22
     97c:	f8 2e       	mov	r15, r24
     97e:	8f e1       	ldi	r24, 0x1F	; 31
     980:	90 e0       	ldi	r25, 0x00	; 0
     982:	2e df       	rcall	.-420    	; 0x7e0 <pvPortMalloc>
     984:	ec 01       	movw	r28, r24
     986:	89 2b       	or	r24, r25
     988:	79 f1       	breq	.+94     	; 0x9e8 <xQueueGenericCreate+0x82>
     98a:	ce 2c       	mov	r12, r14
     98c:	d1 2c       	mov	r13, r1
     98e:	fc 9c       	mul	r15, r12
     990:	80 01       	movw	r16, r0
     992:	fd 9c       	mul	r15, r13
     994:	10 0d       	add	r17, r0
     996:	11 24       	eor	r1, r1
     998:	c8 01       	movw	r24, r16
     99a:	01 96       	adiw	r24, 0x01	; 1
     99c:	21 df       	rcall	.-446    	; 0x7e0 <pvPortMalloc>
     99e:	99 83       	std	Y+1, r25	; 0x01
     9a0:	88 83       	st	Y, r24
     9a2:	00 97       	sbiw	r24, 0x00	; 0
     9a4:	d1 f0       	breq	.+52     	; 0x9da <xQueueGenericCreate+0x74>
     9a6:	9c 01       	movw	r18, r24
     9a8:	20 0f       	add	r18, r16
     9aa:	31 1f       	adc	r19, r17
     9ac:	3b 83       	std	Y+3, r19	; 0x03
     9ae:	2a 83       	std	Y+2, r18	; 0x02
     9b0:	1a 8e       	std	Y+26, r1	; 0x1a
     9b2:	9d 83       	std	Y+5, r25	; 0x05
     9b4:	8c 83       	std	Y+4, r24	; 0x04
     9b6:	0c 19       	sub	r16, r12
     9b8:	1d 09       	sbc	r17, r13
     9ba:	08 0f       	add	r16, r24
     9bc:	19 1f       	adc	r17, r25
     9be:	1f 83       	std	Y+7, r17	; 0x07
     9c0:	0e 83       	std	Y+6, r16	; 0x06
     9c2:	fb 8e       	std	Y+27, r15	; 0x1b
     9c4:	ec 8e       	std	Y+28, r14	; 0x1c
     9c6:	8f ef       	ldi	r24, 0xFF	; 255
     9c8:	8d 8f       	std	Y+29, r24	; 0x1d
     9ca:	8e 8f       	std	Y+30, r24	; 0x1e
     9cc:	ce 01       	movw	r24, r28
     9ce:	08 96       	adiw	r24, 0x08	; 8
     9d0:	fa dc       	rcall	.-1548   	; 0x3c6 <vListInitialise>
     9d2:	ce 01       	movw	r24, r28
     9d4:	41 96       	adiw	r24, 0x11	; 17
     9d6:	f7 dc       	rcall	.-1554   	; 0x3c6 <vListInitialise>
     9d8:	07 c0       	rjmp	.+14     	; 0x9e8 <xQueueGenericCreate+0x82>
     9da:	ce 01       	movw	r24, r28
     9dc:	25 df       	rcall	.-438    	; 0x828 <vPortFree>
     9de:	c0 e0       	ldi	r28, 0x00	; 0
     9e0:	d0 e0       	ldi	r29, 0x00	; 0
     9e2:	02 c0       	rjmp	.+4      	; 0x9e8 <xQueueGenericCreate+0x82>
     9e4:	c0 e0       	ldi	r28, 0x00	; 0
     9e6:	d0 e0       	ldi	r29, 0x00	; 0
     9e8:	ce 01       	movw	r24, r28
     9ea:	df 91       	pop	r29
     9ec:	cf 91       	pop	r28
     9ee:	1f 91       	pop	r17
     9f0:	0f 91       	pop	r16
     9f2:	ff 90       	pop	r15
     9f4:	ef 90       	pop	r14
     9f6:	df 90       	pop	r13
     9f8:	cf 90       	pop	r12
     9fa:	08 95       	ret

000009fc <xQueueGenericSend>:
     9fc:	9f 92       	push	r9
     9fe:	af 92       	push	r10
     a00:	bf 92       	push	r11
     a02:	cf 92       	push	r12
     a04:	df 92       	push	r13
     a06:	ef 92       	push	r14
     a08:	ff 92       	push	r15
     a0a:	0f 93       	push	r16
     a0c:	1f 93       	push	r17
     a0e:	cf 93       	push	r28
     a10:	df 93       	push	r29
     a12:	00 d0       	rcall	.+0      	; 0xa14 <xQueueGenericSend+0x18>
     a14:	1f 92       	push	r1
     a16:	1f 92       	push	r1
     a18:	cd b7       	in	r28, 0x3d	; 61
     a1a:	de b7       	in	r29, 0x3e	; 62
     a1c:	8c 01       	movw	r16, r24
     a1e:	6b 01       	movw	r12, r22
     a20:	5d 83       	std	Y+5, r21	; 0x05
     a22:	4c 83       	std	Y+4, r20	; 0x04
     a24:	92 2e       	mov	r9, r18
     a26:	b1 2c       	mov	r11, r1
     a28:	aa 24       	eor	r10, r10
     a2a:	a3 94       	inc	r10
     a2c:	7c 01       	movw	r14, r24
     a2e:	88 e0       	ldi	r24, 0x08	; 8
     a30:	e8 0e       	add	r14, r24
     a32:	f1 1c       	adc	r15, r1
     a34:	0f b6       	in	r0, 0x3f	; 63
     a36:	f8 94       	cli
     a38:	0f 92       	push	r0
     a3a:	f8 01       	movw	r30, r16
     a3c:	92 8d       	ldd	r25, Z+26	; 0x1a
     a3e:	83 8d       	ldd	r24, Z+27	; 0x1b
     a40:	98 17       	cp	r25, r24
     a42:	90 f4       	brcc	.+36     	; 0xa68 <xQueueGenericSend+0x6c>
     a44:	49 2d       	mov	r20, r9
     a46:	b6 01       	movw	r22, r12
     a48:	c8 01       	movw	r24, r16
     a4a:	ef de       	rcall	.-546    	; 0x82a <prvCopyDataToQueue>
     a4c:	f8 01       	movw	r30, r16
     a4e:	81 89       	ldd	r24, Z+17	; 0x11
     a50:	88 23       	and	r24, r24
     a52:	31 f0       	breq	.+12     	; 0xa60 <xQueueGenericSend+0x64>
     a54:	c8 01       	movw	r24, r16
     a56:	41 96       	adiw	r24, 0x11	; 17
     a58:	28 d4       	rcall	.+2128   	; 0x12aa <xTaskRemoveFromEventList>
     a5a:	81 30       	cpi	r24, 0x01	; 1
     a5c:	09 f4       	brne	.+2      	; 0xa60 <xQueueGenericSend+0x64>
     a5e:	fd dd       	rcall	.-1030   	; 0x65a <vPortYield>
     a60:	0f 90       	pop	r0
     a62:	0f be       	out	0x3f, r0	; 63
     a64:	81 e0       	ldi	r24, 0x01	; 1
     a66:	45 c0       	rjmp	.+138    	; 0xaf2 <xQueueGenericSend+0xf6>
     a68:	8c 81       	ldd	r24, Y+4	; 0x04
     a6a:	9d 81       	ldd	r25, Y+5	; 0x05
     a6c:	89 2b       	or	r24, r25
     a6e:	21 f4       	brne	.+8      	; 0xa78 <xQueueGenericSend+0x7c>
     a70:	0f 90       	pop	r0
     a72:	0f be       	out	0x3f, r0	; 63
     a74:	80 e0       	ldi	r24, 0x00	; 0
     a76:	3d c0       	rjmp	.+122    	; 0xaf2 <xQueueGenericSend+0xf6>
     a78:	b1 10       	cpse	r11, r1
     a7a:	04 c0       	rjmp	.+8      	; 0xa84 <xQueueGenericSend+0x88>
     a7c:	ce 01       	movw	r24, r28
     a7e:	01 96       	adiw	r24, 0x01	; 1
     a80:	55 d4       	rcall	.+2218   	; 0x132c <vTaskSetTimeOutState>
     a82:	ba 2c       	mov	r11, r10
     a84:	0f 90       	pop	r0
     a86:	0f be       	out	0x3f, r0	; 63
     a88:	27 d2       	rcall	.+1102   	; 0xed8 <vTaskSuspendAll>
     a8a:	0f b6       	in	r0, 0x3f	; 63
     a8c:	f8 94       	cli
     a8e:	0f 92       	push	r0
     a90:	f8 01       	movw	r30, r16
     a92:	85 8d       	ldd	r24, Z+29	; 0x1d
     a94:	8f 3f       	cpi	r24, 0xFF	; 255
     a96:	09 f4       	brne	.+2      	; 0xa9a <xQueueGenericSend+0x9e>
     a98:	15 8e       	std	Z+29, r1	; 0x1d
     a9a:	f8 01       	movw	r30, r16
     a9c:	86 8d       	ldd	r24, Z+30	; 0x1e
     a9e:	8f 3f       	cpi	r24, 0xFF	; 255
     aa0:	09 f4       	brne	.+2      	; 0xaa4 <xQueueGenericSend+0xa8>
     aa2:	16 8e       	std	Z+30, r1	; 0x1e
     aa4:	0f 90       	pop	r0
     aa6:	0f be       	out	0x3f, r0	; 63
     aa8:	be 01       	movw	r22, r28
     aaa:	6c 5f       	subi	r22, 0xFC	; 252
     aac:	7f 4f       	sbci	r23, 0xFF	; 255
     aae:	ce 01       	movw	r24, r28
     ab0:	01 96       	adiw	r24, 0x01	; 1
     ab2:	47 d4       	rcall	.+2190   	; 0x1342 <xTaskCheckForTimeOut>
     ab4:	81 11       	cpse	r24, r1
     ab6:	19 c0       	rjmp	.+50     	; 0xaea <xQueueGenericSend+0xee>
     ab8:	0f b6       	in	r0, 0x3f	; 63
     aba:	f8 94       	cli
     abc:	0f 92       	push	r0
     abe:	f8 01       	movw	r30, r16
     ac0:	92 8d       	ldd	r25, Z+26	; 0x1a
     ac2:	0f 90       	pop	r0
     ac4:	0f be       	out	0x3f, r0	; 63
     ac6:	83 8d       	ldd	r24, Z+27	; 0x1b
     ac8:	98 13       	cpse	r25, r24
     aca:	0b c0       	rjmp	.+22     	; 0xae2 <xQueueGenericSend+0xe6>
     acc:	6c 81       	ldd	r22, Y+4	; 0x04
     ace:	7d 81       	ldd	r23, Y+5	; 0x05
     ad0:	c7 01       	movw	r24, r14
     ad2:	d1 d3       	rcall	.+1954   	; 0x1276 <vTaskPlaceOnEventList>
     ad4:	c8 01       	movw	r24, r16
     ad6:	01 df       	rcall	.-510    	; 0x8da <prvUnlockQueue>
     ad8:	c6 d2       	rcall	.+1420   	; 0x1066 <xTaskResumeAll>
     ada:	81 11       	cpse	r24, r1
     adc:	ab cf       	rjmp	.-170    	; 0xa34 <xQueueGenericSend+0x38>
     ade:	bd dd       	rcall	.-1158   	; 0x65a <vPortYield>
     ae0:	a9 cf       	rjmp	.-174    	; 0xa34 <xQueueGenericSend+0x38>
     ae2:	c8 01       	movw	r24, r16
     ae4:	fa de       	rcall	.-524    	; 0x8da <prvUnlockQueue>
     ae6:	bf d2       	rcall	.+1406   	; 0x1066 <xTaskResumeAll>
     ae8:	a5 cf       	rjmp	.-182    	; 0xa34 <xQueueGenericSend+0x38>
     aea:	c8 01       	movw	r24, r16
     aec:	f6 de       	rcall	.-532    	; 0x8da <prvUnlockQueue>
     aee:	bb d2       	rcall	.+1398   	; 0x1066 <xTaskResumeAll>
     af0:	80 e0       	ldi	r24, 0x00	; 0
     af2:	0f 90       	pop	r0
     af4:	0f 90       	pop	r0
     af6:	0f 90       	pop	r0
     af8:	0f 90       	pop	r0
     afa:	0f 90       	pop	r0
     afc:	df 91       	pop	r29
     afe:	cf 91       	pop	r28
     b00:	1f 91       	pop	r17
     b02:	0f 91       	pop	r16
     b04:	ff 90       	pop	r15
     b06:	ef 90       	pop	r14
     b08:	df 90       	pop	r13
     b0a:	cf 90       	pop	r12
     b0c:	bf 90       	pop	r11
     b0e:	af 90       	pop	r10
     b10:	9f 90       	pop	r9
     b12:	08 95       	ret

00000b14 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     b14:	9f 92       	push	r9
     b16:	af 92       	push	r10
     b18:	bf 92       	push	r11
     b1a:	cf 92       	push	r12
     b1c:	df 92       	push	r13
     b1e:	ef 92       	push	r14
     b20:	ff 92       	push	r15
     b22:	0f 93       	push	r16
     b24:	1f 93       	push	r17
     b26:	cf 93       	push	r28
     b28:	df 93       	push	r29
     b2a:	00 d0       	rcall	.+0      	; 0xb2c <xQueueGenericReceive+0x18>
     b2c:	1f 92       	push	r1
     b2e:	1f 92       	push	r1
     b30:	cd b7       	in	r28, 0x3d	; 61
     b32:	de b7       	in	r29, 0x3e	; 62
     b34:	8c 01       	movw	r16, r24
     b36:	6b 01       	movw	r12, r22
     b38:	5d 83       	std	Y+5, r21	; 0x05
     b3a:	4c 83       	std	Y+4, r20	; 0x04
     b3c:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     b3e:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     b40:	aa 24       	eor	r10, r10
     b42:	a3 94       	inc	r10
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b44:	7c 01       	movw	r14, r24
     b46:	81 e1       	ldi	r24, 0x11	; 17
     b48:	e8 0e       	add	r14, r24
     b4a:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     b4c:	0f b6       	in	r0, 0x3f	; 63
     b4e:	f8 94       	cli
     b50:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     b52:	f8 01       	movw	r30, r16
     b54:	82 8d       	ldd	r24, Z+26	; 0x1a
     b56:	88 23       	and	r24, r24
     b58:	21 f1       	breq	.+72     	; 0xba2 <xQueueGenericReceive+0x8e>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     b5a:	e6 80       	ldd	r14, Z+6	; 0x06
     b5c:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     b5e:	b6 01       	movw	r22, r12
     b60:	c8 01       	movw	r24, r16
     b62:	a2 de       	rcall	.-700    	; 0x8a8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     b64:	91 10       	cpse	r9, r1
     b66:	0e c0       	rjmp	.+28     	; 0xb84 <xQueueGenericReceive+0x70>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     b68:	f8 01       	movw	r30, r16
     b6a:	82 8d       	ldd	r24, Z+26	; 0x1a
     b6c:	81 50       	subi	r24, 0x01	; 1
     b6e:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     b70:	80 85       	ldd	r24, Z+8	; 0x08
     b72:	88 23       	and	r24, r24
     b74:	91 f0       	breq	.+36     	; 0xb9a <xQueueGenericReceive+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     b76:	c8 01       	movw	r24, r16
     b78:	08 96       	adiw	r24, 0x08	; 8
     b7a:	97 d3       	rcall	.+1838   	; 0x12aa <xTaskRemoveFromEventList>
     b7c:	81 30       	cpi	r24, 0x01	; 1
						{
							portYIELD_WITHIN_API();
     b7e:	69 f4       	brne	.+26     	; 0xb9a <xQueueGenericReceive+0x86>
     b80:	6c dd       	rcall	.-1320   	; 0x65a <vPortYield>
     b82:	0b c0       	rjmp	.+22     	; 0xb9a <xQueueGenericReceive+0x86>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     b84:	f8 01       	movw	r30, r16
     b86:	f7 82       	std	Z+7, r15	; 0x07
     b88:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     b8a:	81 89       	ldd	r24, Z+17	; 0x11
     b8c:	88 23       	and	r24, r24
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     b8e:	29 f0       	breq	.+10     	; 0xb9a <xQueueGenericReceive+0x86>
     b90:	c8 01       	movw	r24, r16
     b92:	41 96       	adiw	r24, 0x11	; 17
     b94:	8a d3       	rcall	.+1812   	; 0x12aa <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     b96:	81 11       	cpse	r24, r1
     b98:	60 dd       	rcall	.-1344   	; 0x65a <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     b9a:	0f 90       	pop	r0
     b9c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     b9e:	81 e0       	ldi	r24, 0x01	; 1
     ba0:	44 c0       	rjmp	.+136    	; 0xc2a <xQueueGenericReceive+0x116>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     ba2:	8c 81       	ldd	r24, Y+4	; 0x04
     ba4:	9d 81       	ldd	r25, Y+5	; 0x05
     ba6:	89 2b       	or	r24, r25
     ba8:	21 f4       	brne	.+8      	; 0xbb2 <xQueueGenericReceive+0x9e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     baa:	0f 90       	pop	r0
     bac:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     bae:	80 e0       	ldi	r24, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
     bb0:	3c c0       	rjmp	.+120    	; 0xc2a <xQueueGenericReceive+0x116>
     bb2:	b1 10       	cpse	r11, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     bb4:	04 c0       	rjmp	.+8      	; 0xbbe <xQueueGenericReceive+0xaa>
     bb6:	ce 01       	movw	r24, r28
     bb8:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
     bba:	b8 d3       	rcall	.+1904   	; 0x132c <vTaskSetTimeOutState>
				}
			}
		}
		taskEXIT_CRITICAL();
     bbc:	ba 2c       	mov	r11, r10
     bbe:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     bc0:	0f be       	out	0x3f, r0	; 63
     bc2:	8a d1       	rcall	.+788    	; 0xed8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     bc4:	0f b6       	in	r0, 0x3f	; 63
     bc6:	f8 94       	cli
     bc8:	0f 92       	push	r0
     bca:	f8 01       	movw	r30, r16
     bcc:	85 8d       	ldd	r24, Z+29	; 0x1d
     bce:	8f 3f       	cpi	r24, 0xFF	; 255
     bd0:	09 f4       	brne	.+2      	; 0xbd4 <xQueueGenericReceive+0xc0>
     bd2:	15 8e       	std	Z+29, r1	; 0x1d
     bd4:	f8 01       	movw	r30, r16
     bd6:	86 8d       	ldd	r24, Z+30	; 0x1e
     bd8:	8f 3f       	cpi	r24, 0xFF	; 255
     bda:	09 f4       	brne	.+2      	; 0xbde <xQueueGenericReceive+0xca>
     bdc:	16 8e       	std	Z+30, r1	; 0x1e
     bde:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     be0:	0f be       	out	0x3f, r0	; 63
     be2:	be 01       	movw	r22, r28
     be4:	6c 5f       	subi	r22, 0xFC	; 252
     be6:	7f 4f       	sbci	r23, 0xFF	; 255
     be8:	ce 01       	movw	r24, r28
     bea:	01 96       	adiw	r24, 0x01	; 1
     bec:	aa d3       	rcall	.+1876   	; 0x1342 <xTaskCheckForTimeOut>
     bee:	81 11       	cpse	r24, r1
     bf0:	18 c0       	rjmp	.+48     	; 0xc22 <xQueueGenericReceive+0x10e>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     bf2:	0f b6       	in	r0, 0x3f	; 63
     bf4:	f8 94       	cli
     bf6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     bf8:	f8 01       	movw	r30, r16
	taskEXIT_CRITICAL();
     bfa:	82 8d       	ldd	r24, Z+26	; 0x1a
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     bfc:	0f 90       	pop	r0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     bfe:	0f be       	out	0x3f, r0	; 63
     c00:	81 11       	cpse	r24, r1
     c02:	0b c0       	rjmp	.+22     	; 0xc1a <xQueueGenericReceive+0x106>
     c04:	6c 81       	ldd	r22, Y+4	; 0x04
				prvUnlockQueue( pxQueue );
     c06:	7d 81       	ldd	r23, Y+5	; 0x05
     c08:	c7 01       	movw	r24, r14
				if( xTaskResumeAll() == pdFALSE )
     c0a:	35 d3       	rcall	.+1642   	; 0x1276 <vTaskPlaceOnEventList>
     c0c:	c8 01       	movw	r24, r16
				{
					portYIELD_WITHIN_API();
     c0e:	65 de       	rcall	.-822    	; 0x8da <prvUnlockQueue>
     c10:	2a d2       	rcall	.+1108   	; 0x1066 <xTaskResumeAll>
     c12:	81 11       	cpse	r24, r1
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     c14:	9b cf       	rjmp	.-202    	; 0xb4c <xQueueGenericReceive+0x38>
     c16:	21 dd       	rcall	.-1470   	; 0x65a <vPortYield>
     c18:	99 cf       	rjmp	.-206    	; 0xb4c <xQueueGenericReceive+0x38>
				( void ) xTaskResumeAll();
     c1a:	c8 01       	movw	r24, r16
     c1c:	5e de       	rcall	.-836    	; 0x8da <prvUnlockQueue>
     c1e:	23 d2       	rcall	.+1094   	; 0x1066 <xTaskResumeAll>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     c20:	95 cf       	rjmp	.-214    	; 0xb4c <xQueueGenericReceive+0x38>
     c22:	c8 01       	movw	r24, r16
     c24:	5a de       	rcall	.-844    	; 0x8da <prvUnlockQueue>
			( void ) xTaskResumeAll();
     c26:	1f d2       	rcall	.+1086   	; 0x1066 <xTaskResumeAll>
     c28:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     c2a:	0f 90       	pop	r0
		}
	}
}
     c2c:	0f 90       	pop	r0
     c2e:	0f 90       	pop	r0
     c30:	0f 90       	pop	r0
     c32:	0f 90       	pop	r0
     c34:	df 91       	pop	r29
     c36:	cf 91       	pop	r28
     c38:	1f 91       	pop	r17
     c3a:	0f 91       	pop	r16
     c3c:	ff 90       	pop	r15
     c3e:	ef 90       	pop	r14
     c40:	df 90       	pop	r13
     c42:	cf 90       	pop	r12
     c44:	bf 90       	pop	r11
     c46:	af 90       	pop	r10
     c48:	9f 90       	pop	r9
     c4a:	08 95       	ret

00000c4c <prvIdleTask>:
     c4c:	c1 e4       	ldi	r28, 0x41	; 65
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
     c4e:	d8 e0       	ldi	r29, 0x08	; 8
     c50:	88 81       	ld	r24, Y
     c52:	82 30       	cpi	r24, 0x02	; 2
     c54:	e8 f3       	brcs	.-6      	; 0xc50 <prvIdleTask+0x4>
     c56:	01 dd       	rcall	.-1534   	; 0x65a <vPortYield>
     c58:	fb cf       	rjmp	.-10     	; 0xc50 <prvIdleTask+0x4>

00000c5a <prvAddCurrentTaskToDelayedList>:
     c5a:	cf 93       	push	r28
     c5c:	df 93       	push	r29
     c5e:	ec 01       	movw	r28, r24
     c60:	e0 91 4a 08 	lds	r30, 0x084A	; 0x80084a <pxCurrentTCB>
     c64:	f0 91 4b 08 	lds	r31, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
     c68:	93 83       	std	Z+3, r25	; 0x03
     c6a:	82 83       	std	Z+2, r24	; 0x02
     c6c:	80 91 1f 08 	lds	r24, 0x081F	; 0x80081f <xTickCount>
     c70:	90 91 20 08 	lds	r25, 0x0820	; 0x800820 <xTickCount+0x1>
     c74:	c8 17       	cp	r28, r24
     c76:	d9 07       	cpc	r29, r25
     c78:	60 f4       	brcc	.+24     	; 0xc92 <prvAddCurrentTaskToDelayedList+0x38>
     c7a:	60 91 4a 08 	lds	r22, 0x084A	; 0x80084a <pxCurrentTCB>
     c7e:	70 91 4b 08 	lds	r23, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
     c82:	80 91 2b 08 	lds	r24, 0x082B	; 0x80082b <pxOverflowDelayedTaskList>
     c86:	90 91 2c 08 	lds	r25, 0x082C	; 0x80082c <pxOverflowDelayedTaskList+0x1>
     c8a:	6e 5f       	subi	r22, 0xFE	; 254
     c8c:	7f 4f       	sbci	r23, 0xFF	; 255
     c8e:	d4 db       	rcall	.-2136   	; 0x438 <vListInsert>
     c90:	16 c0       	rjmp	.+44     	; 0xcbe <prvAddCurrentTaskToDelayedList+0x64>
     c92:	60 91 4a 08 	lds	r22, 0x084A	; 0x80084a <pxCurrentTCB>
     c96:	70 91 4b 08 	lds	r23, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
     c9a:	80 91 2d 08 	lds	r24, 0x082D	; 0x80082d <pxDelayedTaskList>
     c9e:	90 91 2e 08 	lds	r25, 0x082E	; 0x80082e <pxDelayedTaskList+0x1>
     ca2:	6e 5f       	subi	r22, 0xFE	; 254
     ca4:	7f 4f       	sbci	r23, 0xFF	; 255
     ca6:	c8 db       	rcall	.-2160   	; 0x438 <vListInsert>
     ca8:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
     cac:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     cb0:	c8 17       	cp	r28, r24
     cb2:	d9 07       	cpc	r29, r25
     cb4:	20 f4       	brcc	.+8      	; 0xcbe <prvAddCurrentTaskToDelayedList+0x64>
     cb6:	d0 93 01 02 	sts	0x0201, r29	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     cba:	c0 93 00 02 	sts	0x0200, r28	; 0x800200 <__DATA_REGION_ORIGIN__>
     cbe:	df 91       	pop	r29
     cc0:	cf 91       	pop	r28
     cc2:	08 95       	ret

00000cc4 <xTaskGenericCreate>:
     cc4:	4f 92       	push	r4
     cc6:	5f 92       	push	r5
     cc8:	6f 92       	push	r6
     cca:	7f 92       	push	r7
     ccc:	8f 92       	push	r8
     cce:	9f 92       	push	r9
     cd0:	af 92       	push	r10
     cd2:	bf 92       	push	r11
     cd4:	cf 92       	push	r12
     cd6:	df 92       	push	r13
     cd8:	ef 92       	push	r14
     cda:	ff 92       	push	r15
     cdc:	0f 93       	push	r16
     cde:	cf 93       	push	r28
     ce0:	df 93       	push	r29
     ce2:	5c 01       	movw	r10, r24
     ce4:	4b 01       	movw	r8, r22
     ce6:	3a 01       	movw	r6, r20
     ce8:	29 01       	movw	r4, r18
     cea:	81 e2       	ldi	r24, 0x21	; 33
     cec:	90 e0       	ldi	r25, 0x00	; 0
     cee:	78 dd       	rcall	.-1296   	; 0x7e0 <pvPortMalloc>
     cf0:	ec 01       	movw	r28, r24
     cf2:	89 2b       	or	r24, r25
     cf4:	09 f4       	brne	.+2      	; 0xcf8 <xTaskGenericCreate+0x34>
     cf6:	9c c0       	rjmp	.+312    	; 0xe30 <xTaskGenericCreate+0x16c>
     cf8:	c1 14       	cp	r12, r1
     cfa:	d1 04       	cpc	r13, r1
     cfc:	09 f0       	breq	.+2      	; 0xd00 <xTaskGenericCreate+0x3c>
     cfe:	94 c0       	rjmp	.+296    	; 0xe28 <xTaskGenericCreate+0x164>
     d00:	c3 01       	movw	r24, r6
     d02:	6e dd       	rcall	.-1316   	; 0x7e0 <pvPortMalloc>
     d04:	98 8f       	std	Y+24, r25	; 0x18
     d06:	8f 8b       	std	Y+23, r24	; 0x17
     d08:	00 97       	sbiw	r24, 0x00	; 0
     d0a:	19 f4       	brne	.+6      	; 0xd12 <xTaskGenericCreate+0x4e>
     d0c:	ce 01       	movw	r24, r28
     d0e:	8c dd       	rcall	.-1256   	; 0x828 <vPortFree>
     d10:	8f c0       	rjmp	.+286    	; 0xe30 <xTaskGenericCreate+0x16c>
     d12:	a3 01       	movw	r20, r6
     d14:	65 ea       	ldi	r22, 0xA5	; 165
     d16:	70 e0       	ldi	r23, 0x00	; 0
     d18:	79 d3       	rcall	.+1778   	; 0x140c <memset>
     d1a:	93 01       	movw	r18, r6
     d1c:	21 50       	subi	r18, 0x01	; 1
     d1e:	31 09       	sbc	r19, r1
     d20:	8f 89       	ldd	r24, Y+23	; 0x17
     d22:	98 8d       	ldd	r25, Y+24	; 0x18
     d24:	3c 01       	movw	r6, r24
     d26:	62 0e       	add	r6, r18
     d28:	73 1e       	adc	r7, r19
     d2a:	48 e0       	ldi	r20, 0x08	; 8
     d2c:	50 e0       	ldi	r21, 0x00	; 0
     d2e:	b4 01       	movw	r22, r8
     d30:	ce 01       	movw	r24, r28
     d32:	49 96       	adiw	r24, 0x19	; 25
     d34:	72 d3       	rcall	.+1764   	; 0x141a <strncpy>
     d36:	18 a2       	std	Y+32, r1	; 0x20
     d38:	1e 8a       	std	Y+22, r1	; 0x16
     d3a:	6e 01       	movw	r12, r28
     d3c:	82 e0       	ldi	r24, 0x02	; 2
     d3e:	c8 0e       	add	r12, r24
     d40:	d1 1c       	adc	r13, r1
     d42:	c6 01       	movw	r24, r12
     d44:	4e db       	rcall	.-2404   	; 0x3e2 <vListInitialiseItem>
     d46:	ce 01       	movw	r24, r28
     d48:	0c 96       	adiw	r24, 0x0c	; 12
     d4a:	4b db       	rcall	.-2410   	; 0x3e2 <vListInitialiseItem>
     d4c:	d9 87       	std	Y+9, r29	; 0x09
     d4e:	c8 87       	std	Y+8, r28	; 0x08
     d50:	81 e0       	ldi	r24, 0x01	; 1
     d52:	90 e0       	ldi	r25, 0x00	; 0
     d54:	9d 87       	std	Y+13, r25	; 0x0d
     d56:	8c 87       	std	Y+12, r24	; 0x0c
     d58:	db 8b       	std	Y+19, r29	; 0x13
     d5a:	ca 8b       	std	Y+18, r28	; 0x12
     d5c:	a2 01       	movw	r20, r4
     d5e:	b5 01       	movw	r22, r10
     d60:	c3 01       	movw	r24, r6
     d62:	cb db       	rcall	.-2154   	; 0x4fa <pxPortInitialiseStack>
     d64:	99 83       	std	Y+1, r25	; 0x01
     d66:	88 83       	st	Y, r24
     d68:	e1 14       	cp	r14, r1
     d6a:	f1 04       	cpc	r15, r1
     d6c:	19 f0       	breq	.+6      	; 0xd74 <xTaskGenericCreate+0xb0>
     d6e:	f7 01       	movw	r30, r14
     d70:	d1 83       	std	Z+1, r29	; 0x01
     d72:	c0 83       	st	Z, r28
     d74:	0f b6       	in	r0, 0x3f	; 63
     d76:	f8 94       	cli
     d78:	0f 92       	push	r0
     d7a:	80 91 21 08 	lds	r24, 0x0821	; 0x800821 <uxCurrentNumberOfTasks>
     d7e:	8f 5f       	subi	r24, 0xFF	; 255
     d80:	80 93 21 08 	sts	0x0821, r24	; 0x800821 <uxCurrentNumberOfTasks>
     d84:	80 91 4a 08 	lds	r24, 0x084A	; 0x80084a <pxCurrentTCB>
     d88:	90 91 4b 08 	lds	r25, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
     d8c:	89 2b       	or	r24, r25
     d8e:	49 f4       	brne	.+18     	; 0xda2 <xTaskGenericCreate+0xde>
     d90:	d0 93 4b 08 	sts	0x084B, r29	; 0x80084b <pxCurrentTCB+0x1>
     d94:	c0 93 4a 08 	sts	0x084A, r28	; 0x80084a <pxCurrentTCB>
     d98:	80 91 21 08 	lds	r24, 0x0821	; 0x800821 <uxCurrentNumberOfTasks>
     d9c:	81 30       	cpi	r24, 0x01	; 1
     d9e:	81 f4       	brne	.+32     	; 0xdc0 <xTaskGenericCreate+0xfc>
     da0:	49 c0       	rjmp	.+146    	; 0xe34 <xTaskGenericCreate+0x170>
     da2:	80 91 1c 08 	lds	r24, 0x081C	; 0x80081c <xSchedulerRunning>
     da6:	81 11       	cpse	r24, r1
     da8:	0b c0       	rjmp	.+22     	; 0xdc0 <xTaskGenericCreate+0xfc>
     daa:	e0 91 4a 08 	lds	r30, 0x084A	; 0x80084a <pxCurrentTCB>
     dae:	f0 91 4b 08 	lds	r31, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
     db2:	86 89       	ldd	r24, Z+22	; 0x16
     db4:	08 17       	cp	r16, r24
     db6:	20 f0       	brcs	.+8      	; 0xdc0 <xTaskGenericCreate+0xfc>
     db8:	d0 93 4b 08 	sts	0x084B, r29	; 0x80084b <pxCurrentTCB+0x1>
     dbc:	c0 93 4a 08 	sts	0x084A, r28	; 0x80084a <pxCurrentTCB>
     dc0:	8e 89       	ldd	r24, Y+22	; 0x16
     dc2:	90 91 1e 08 	lds	r25, 0x081E	; 0x80081e <uxTopUsedPriority>
     dc6:	98 17       	cp	r25, r24
     dc8:	10 f4       	brcc	.+4      	; 0xdce <xTaskGenericCreate+0x10a>
     dca:	80 93 1e 08 	sts	0x081E, r24	; 0x80081e <uxTopUsedPriority>
     dce:	90 91 17 08 	lds	r25, 0x0817	; 0x800817 <uxTCBNumber>
     dd2:	9f 5f       	subi	r25, 0xFF	; 255
     dd4:	90 93 17 08 	sts	0x0817, r25	; 0x800817 <uxTCBNumber>
     dd8:	90 91 1d 08 	lds	r25, 0x081D	; 0x80081d <uxTopReadyPriority>
     ddc:	98 17       	cp	r25, r24
     dde:	10 f4       	brcc	.+4      	; 0xde4 <xTaskGenericCreate+0x120>
     de0:	80 93 1d 08 	sts	0x081D, r24	; 0x80081d <uxTopReadyPriority>
     de4:	90 e0       	ldi	r25, 0x00	; 0
     de6:	9c 01       	movw	r18, r24
     de8:	22 0f       	add	r18, r18
     dea:	33 1f       	adc	r19, r19
     dec:	22 0f       	add	r18, r18
     dee:	33 1f       	adc	r19, r19
     df0:	22 0f       	add	r18, r18
     df2:	33 1f       	adc	r19, r19
     df4:	82 0f       	add	r24, r18
     df6:	93 1f       	adc	r25, r19
     df8:	b6 01       	movw	r22, r12
     dfa:	8f 5b       	subi	r24, 0xBF	; 191
     dfc:	97 4f       	sbci	r25, 0xF7	; 247
     dfe:	f5 da       	rcall	.-2582   	; 0x3ea <vListInsertEnd>
     e00:	0f 90       	pop	r0
     e02:	0f be       	out	0x3f, r0	; 63
     e04:	80 91 1c 08 	lds	r24, 0x081C	; 0x80081c <xSchedulerRunning>
     e08:	88 23       	and	r24, r24
     e0a:	51 f0       	breq	.+20     	; 0xe20 <xTaskGenericCreate+0x15c>
     e0c:	e0 91 4a 08 	lds	r30, 0x084A	; 0x80084a <pxCurrentTCB>
     e10:	f0 91 4b 08 	lds	r31, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
     e14:	86 89       	ldd	r24, Z+22	; 0x16
     e16:	80 17       	cp	r24, r16
     e18:	28 f4       	brcc	.+10     	; 0xe24 <xTaskGenericCreate+0x160>
     e1a:	1f dc       	rcall	.-1986   	; 0x65a <vPortYield>
     e1c:	81 e0       	ldi	r24, 0x01	; 1
     e1e:	23 c0       	rjmp	.+70     	; 0xe66 <xTaskGenericCreate+0x1a2>
     e20:	81 e0       	ldi	r24, 0x01	; 1
     e22:	21 c0       	rjmp	.+66     	; 0xe66 <xTaskGenericCreate+0x1a2>
     e24:	81 e0       	ldi	r24, 0x01	; 1
     e26:	1f c0       	rjmp	.+62     	; 0xe66 <xTaskGenericCreate+0x1a2>
     e28:	d8 8e       	std	Y+24, r13	; 0x18
     e2a:	cf 8a       	std	Y+23, r12	; 0x17
     e2c:	c6 01       	movw	r24, r12
     e2e:	71 cf       	rjmp	.-286    	; 0xd12 <xTaskGenericCreate+0x4e>
     e30:	8f ef       	ldi	r24, 0xFF	; 255
     e32:	19 c0       	rjmp	.+50     	; 0xe66 <xTaskGenericCreate+0x1a2>
     e34:	81 e4       	ldi	r24, 0x41	; 65
     e36:	98 e0       	ldi	r25, 0x08	; 8
     e38:	c6 da       	rcall	.-2676   	; 0x3c6 <vListInitialise>
     e3a:	88 e3       	ldi	r24, 0x38	; 56
     e3c:	98 e0       	ldi	r25, 0x08	; 8
     e3e:	c3 da       	rcall	.-2682   	; 0x3c6 <vListInitialise>
     e40:	8f e2       	ldi	r24, 0x2F	; 47
     e42:	98 e0       	ldi	r25, 0x08	; 8
     e44:	c0 da       	rcall	.-2688   	; 0x3c6 <vListInitialise>
     e46:	82 e2       	ldi	r24, 0x22	; 34
     e48:	98 e0       	ldi	r25, 0x08	; 8
     e4a:	bd da       	rcall	.-2694   	; 0x3c6 <vListInitialise>
     e4c:	88 e3       	ldi	r24, 0x38	; 56
     e4e:	98 e0       	ldi	r25, 0x08	; 8
     e50:	90 93 2e 08 	sts	0x082E, r25	; 0x80082e <pxDelayedTaskList+0x1>
     e54:	80 93 2d 08 	sts	0x082D, r24	; 0x80082d <pxDelayedTaskList>
     e58:	8f e2       	ldi	r24, 0x2F	; 47
     e5a:	98 e0       	ldi	r25, 0x08	; 8
     e5c:	90 93 2c 08 	sts	0x082C, r25	; 0x80082c <pxOverflowDelayedTaskList+0x1>
     e60:	80 93 2b 08 	sts	0x082B, r24	; 0x80082b <pxOverflowDelayedTaskList>
     e64:	ad cf       	rjmp	.-166    	; 0xdc0 <xTaskGenericCreate+0xfc>
     e66:	df 91       	pop	r29
     e68:	cf 91       	pop	r28
     e6a:	0f 91       	pop	r16
     e6c:	ff 90       	pop	r15
     e6e:	ef 90       	pop	r14
     e70:	df 90       	pop	r13
     e72:	cf 90       	pop	r12
     e74:	bf 90       	pop	r11
     e76:	af 90       	pop	r10
     e78:	9f 90       	pop	r9
     e7a:	8f 90       	pop	r8
     e7c:	7f 90       	pop	r7
     e7e:	6f 90       	pop	r6
     e80:	5f 90       	pop	r5
     e82:	4f 90       	pop	r4
     e84:	08 95       	ret

00000e86 <vTaskStartScheduler>:
     e86:	af 92       	push	r10
     e88:	bf 92       	push	r11
     e8a:	cf 92       	push	r12
     e8c:	df 92       	push	r13
     e8e:	ef 92       	push	r14
     e90:	ff 92       	push	r15
     e92:	0f 93       	push	r16
     e94:	a1 2c       	mov	r10, r1
     e96:	b1 2c       	mov	r11, r1
     e98:	c1 2c       	mov	r12, r1
     e9a:	d1 2c       	mov	r13, r1
     e9c:	e1 2c       	mov	r14, r1
     e9e:	f1 2c       	mov	r15, r1
     ea0:	00 e0       	ldi	r16, 0x00	; 0
     ea2:	20 e0       	ldi	r18, 0x00	; 0
     ea4:	30 e0       	ldi	r19, 0x00	; 0
     ea6:	45 e5       	ldi	r20, 0x55	; 85
     ea8:	50 e0       	ldi	r21, 0x00	; 0
     eaa:	60 e3       	ldi	r22, 0x30	; 48
     eac:	72 e0       	ldi	r23, 0x02	; 2
     eae:	86 e2       	ldi	r24, 0x26	; 38
     eb0:	96 e0       	ldi	r25, 0x06	; 6
     eb2:	08 df       	rcall	.-496    	; 0xcc4 <xTaskGenericCreate>
     eb4:	81 30       	cpi	r24, 0x01	; 1
     eb6:	41 f4       	brne	.+16     	; 0xec8 <vTaskStartScheduler+0x42>
     eb8:	f8 94       	cli
     eba:	80 93 1c 08 	sts	0x081C, r24	; 0x80081c <xSchedulerRunning>
     ebe:	10 92 20 08 	sts	0x0820, r1	; 0x800820 <xTickCount+0x1>
     ec2:	10 92 1f 08 	sts	0x081F, r1	; 0x80081f <xTickCount>
     ec6:	8b db       	rcall	.-2282   	; 0x5de <xPortStartScheduler>
     ec8:	0f 91       	pop	r16
     eca:	ff 90       	pop	r15
     ecc:	ef 90       	pop	r14
     ece:	df 90       	pop	r13
     ed0:	cf 90       	pop	r12
     ed2:	bf 90       	pop	r11
     ed4:	af 90       	pop	r10
     ed6:	08 95       	ret

00000ed8 <vTaskSuspendAll>:
     ed8:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <uxSchedulerSuspended>
     edc:	8f 5f       	subi	r24, 0xFF	; 255
     ede:	80 93 1b 08 	sts	0x081B, r24	; 0x80081b <uxSchedulerSuspended>
     ee2:	08 95       	ret

00000ee4 <vTaskIncrementTick>:
     ee4:	0f 93       	push	r16
     ee6:	1f 93       	push	r17
     ee8:	cf 93       	push	r28
     eea:	df 93       	push	r29
     eec:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <uxSchedulerSuspended>
     ef0:	81 11       	cpse	r24, r1
     ef2:	af c0       	rjmp	.+350    	; 0x1052 <vTaskIncrementTick+0x16e>
     ef4:	80 91 1f 08 	lds	r24, 0x081F	; 0x80081f <xTickCount>
     ef8:	90 91 20 08 	lds	r25, 0x0820	; 0x800820 <xTickCount+0x1>
     efc:	01 96       	adiw	r24, 0x01	; 1
     efe:	90 93 20 08 	sts	0x0820, r25	; 0x800820 <xTickCount+0x1>
     f02:	80 93 1f 08 	sts	0x081F, r24	; 0x80081f <xTickCount>
     f06:	80 91 1f 08 	lds	r24, 0x081F	; 0x80081f <xTickCount>
     f0a:	90 91 20 08 	lds	r25, 0x0820	; 0x800820 <xTickCount+0x1>
     f0e:	89 2b       	or	r24, r25
     f10:	99 f5       	brne	.+102    	; 0xf78 <vTaskIncrementTick+0x94>
     f12:	80 91 2d 08 	lds	r24, 0x082D	; 0x80082d <pxDelayedTaskList>
     f16:	90 91 2e 08 	lds	r25, 0x082E	; 0x80082e <pxDelayedTaskList+0x1>
     f1a:	20 91 2b 08 	lds	r18, 0x082B	; 0x80082b <pxOverflowDelayedTaskList>
     f1e:	30 91 2c 08 	lds	r19, 0x082C	; 0x80082c <pxOverflowDelayedTaskList+0x1>
     f22:	30 93 2e 08 	sts	0x082E, r19	; 0x80082e <pxDelayedTaskList+0x1>
     f26:	20 93 2d 08 	sts	0x082D, r18	; 0x80082d <pxDelayedTaskList>
     f2a:	90 93 2c 08 	sts	0x082C, r25	; 0x80082c <pxOverflowDelayedTaskList+0x1>
     f2e:	80 93 2b 08 	sts	0x082B, r24	; 0x80082b <pxOverflowDelayedTaskList>
     f32:	80 91 18 08 	lds	r24, 0x0818	; 0x800818 <xNumOfOverflows>
     f36:	8f 5f       	subi	r24, 0xFF	; 255
     f38:	80 93 18 08 	sts	0x0818, r24	; 0x800818 <xNumOfOverflows>
     f3c:	e0 91 2d 08 	lds	r30, 0x082D	; 0x80082d <pxDelayedTaskList>
     f40:	f0 91 2e 08 	lds	r31, 0x082E	; 0x80082e <pxDelayedTaskList+0x1>
     f44:	80 81       	ld	r24, Z
     f46:	81 11       	cpse	r24, r1
     f48:	07 c0       	rjmp	.+14     	; 0xf58 <vTaskIncrementTick+0x74>
     f4a:	8f ef       	ldi	r24, 0xFF	; 255
     f4c:	9f ef       	ldi	r25, 0xFF	; 255
     f4e:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     f52:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
     f56:	10 c0       	rjmp	.+32     	; 0xf78 <vTaskIncrementTick+0x94>
     f58:	e0 91 2d 08 	lds	r30, 0x082D	; 0x80082d <pxDelayedTaskList>
     f5c:	f0 91 2e 08 	lds	r31, 0x082E	; 0x80082e <pxDelayedTaskList+0x1>
     f60:	05 80       	ldd	r0, Z+5	; 0x05
     f62:	f6 81       	ldd	r31, Z+6	; 0x06
     f64:	e0 2d       	mov	r30, r0
     f66:	06 80       	ldd	r0, Z+6	; 0x06
     f68:	f7 81       	ldd	r31, Z+7	; 0x07
     f6a:	e0 2d       	mov	r30, r0
     f6c:	82 81       	ldd	r24, Z+2	; 0x02
     f6e:	93 81       	ldd	r25, Z+3	; 0x03
     f70:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     f74:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
     f78:	20 91 1f 08 	lds	r18, 0x081F	; 0x80081f <xTickCount>
     f7c:	30 91 20 08 	lds	r19, 0x0820	; 0x800820 <xTickCount+0x1>
     f80:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
     f84:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     f88:	28 17       	cp	r18, r24
     f8a:	39 07       	cpc	r19, r25
     f8c:	08 f4       	brcc	.+2      	; 0xf90 <vTaskIncrementTick+0xac>
     f8e:	66 c0       	rjmp	.+204    	; 0x105c <vTaskIncrementTick+0x178>
     f90:	e0 91 2d 08 	lds	r30, 0x082D	; 0x80082d <pxDelayedTaskList>
     f94:	f0 91 2e 08 	lds	r31, 0x082E	; 0x80082e <pxDelayedTaskList+0x1>
     f98:	80 81       	ld	r24, Z
     f9a:	88 23       	and	r24, r24
     f9c:	99 f0       	breq	.+38     	; 0xfc4 <vTaskIncrementTick+0xe0>
     f9e:	e0 91 2d 08 	lds	r30, 0x082D	; 0x80082d <pxDelayedTaskList>
     fa2:	f0 91 2e 08 	lds	r31, 0x082E	; 0x80082e <pxDelayedTaskList+0x1>
     fa6:	05 80       	ldd	r0, Z+5	; 0x05
     fa8:	f6 81       	ldd	r31, Z+6	; 0x06
     faa:	e0 2d       	mov	r30, r0
     fac:	c6 81       	ldd	r28, Z+6	; 0x06
     fae:	d7 81       	ldd	r29, Z+7	; 0x07
     fb0:	8a 81       	ldd	r24, Y+2	; 0x02
     fb2:	9b 81       	ldd	r25, Y+3	; 0x03
     fb4:	20 91 1f 08 	lds	r18, 0x081F	; 0x80081f <xTickCount>
     fb8:	30 91 20 08 	lds	r19, 0x0820	; 0x800820 <xTickCount+0x1>
     fbc:	28 17       	cp	r18, r24
     fbe:	39 07       	cpc	r19, r25
     fc0:	f8 f4       	brcc	.+62     	; 0x1000 <vTaskIncrementTick+0x11c>
     fc2:	19 c0       	rjmp	.+50     	; 0xff6 <vTaskIncrementTick+0x112>
     fc4:	8f ef       	ldi	r24, 0xFF	; 255
     fc6:	9f ef       	ldi	r25, 0xFF	; 255
     fc8:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     fcc:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
     fd0:	45 c0       	rjmp	.+138    	; 0x105c <vTaskIncrementTick+0x178>
     fd2:	e0 91 2d 08 	lds	r30, 0x082D	; 0x80082d <pxDelayedTaskList>
     fd6:	f0 91 2e 08 	lds	r31, 0x082E	; 0x80082e <pxDelayedTaskList+0x1>
     fda:	05 80       	ldd	r0, Z+5	; 0x05
     fdc:	f6 81       	ldd	r31, Z+6	; 0x06
     fde:	e0 2d       	mov	r30, r0
     fe0:	c6 81       	ldd	r28, Z+6	; 0x06
     fe2:	d7 81       	ldd	r29, Z+7	; 0x07
     fe4:	8a 81       	ldd	r24, Y+2	; 0x02
     fe6:	9b 81       	ldd	r25, Y+3	; 0x03
     fe8:	20 91 1f 08 	lds	r18, 0x081F	; 0x80081f <xTickCount>
     fec:	30 91 20 08 	lds	r19, 0x0820	; 0x800820 <xTickCount+0x1>
     ff0:	28 17       	cp	r18, r24
     ff2:	39 07       	cpc	r19, r25
     ff4:	28 f4       	brcc	.+10     	; 0x1000 <vTaskIncrementTick+0x11c>
     ff6:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     ffa:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
     ffe:	2e c0       	rjmp	.+92     	; 0x105c <vTaskIncrementTick+0x178>
    1000:	8e 01       	movw	r16, r28
    1002:	0e 5f       	subi	r16, 0xFE	; 254
    1004:	1f 4f       	sbci	r17, 0xFF	; 255
    1006:	c8 01       	movw	r24, r16
    1008:	52 da       	rcall	.-2908   	; 0x4ae <vListRemove>
    100a:	8c 89       	ldd	r24, Y+20	; 0x14
    100c:	9d 89       	ldd	r25, Y+21	; 0x15
    100e:	89 2b       	or	r24, r25
    1010:	19 f0       	breq	.+6      	; 0x1018 <vTaskIncrementTick+0x134>
    1012:	ce 01       	movw	r24, r28
    1014:	0c 96       	adiw	r24, 0x0c	; 12
    1016:	4b da       	rcall	.-2922   	; 0x4ae <vListRemove>
    1018:	8e 89       	ldd	r24, Y+22	; 0x16
    101a:	90 91 1d 08 	lds	r25, 0x081D	; 0x80081d <uxTopReadyPriority>
    101e:	98 17       	cp	r25, r24
    1020:	10 f4       	brcc	.+4      	; 0x1026 <vTaskIncrementTick+0x142>
    1022:	80 93 1d 08 	sts	0x081D, r24	; 0x80081d <uxTopReadyPriority>
    1026:	90 e0       	ldi	r25, 0x00	; 0
    1028:	9c 01       	movw	r18, r24
    102a:	22 0f       	add	r18, r18
    102c:	33 1f       	adc	r19, r19
    102e:	22 0f       	add	r18, r18
    1030:	33 1f       	adc	r19, r19
    1032:	22 0f       	add	r18, r18
    1034:	33 1f       	adc	r19, r19
    1036:	82 0f       	add	r24, r18
    1038:	93 1f       	adc	r25, r19
    103a:	b8 01       	movw	r22, r16
    103c:	8f 5b       	subi	r24, 0xBF	; 191
    103e:	97 4f       	sbci	r25, 0xF7	; 247
    1040:	d4 d9       	rcall	.-3160   	; 0x3ea <vListInsertEnd>
    1042:	e0 91 2d 08 	lds	r30, 0x082D	; 0x80082d <pxDelayedTaskList>
    1046:	f0 91 2e 08 	lds	r31, 0x082E	; 0x80082e <pxDelayedTaskList+0x1>
    104a:	80 81       	ld	r24, Z
    104c:	81 11       	cpse	r24, r1
    104e:	c1 cf       	rjmp	.-126    	; 0xfd2 <vTaskIncrementTick+0xee>
    1050:	b9 cf       	rjmp	.-142    	; 0xfc4 <vTaskIncrementTick+0xe0>
    1052:	80 91 1a 08 	lds	r24, 0x081A	; 0x80081a <uxMissedTicks>
    1056:	8f 5f       	subi	r24, 0xFF	; 255
    1058:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <uxMissedTicks>
    105c:	df 91       	pop	r29
    105e:	cf 91       	pop	r28
    1060:	1f 91       	pop	r17
    1062:	0f 91       	pop	r16
    1064:	08 95       	ret

00001066 <xTaskResumeAll>:
    1066:	cf 92       	push	r12
    1068:	df 92       	push	r13
    106a:	ef 92       	push	r14
    106c:	ff 92       	push	r15
    106e:	0f 93       	push	r16
    1070:	1f 93       	push	r17
    1072:	cf 93       	push	r28
    1074:	df 93       	push	r29
    1076:	0f b6       	in	r0, 0x3f	; 63
    1078:	f8 94       	cli
    107a:	0f 92       	push	r0
    107c:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <uxSchedulerSuspended>
    1080:	81 50       	subi	r24, 0x01	; 1
    1082:	80 93 1b 08 	sts	0x081B, r24	; 0x80081b <uxSchedulerSuspended>
    1086:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <uxSchedulerSuspended>
    108a:	81 11       	cpse	r24, r1
    108c:	5f c0       	rjmp	.+190    	; 0x114c <xTaskResumeAll+0xe6>
    108e:	80 91 21 08 	lds	r24, 0x0821	; 0x800821 <uxCurrentNumberOfTasks>
    1092:	81 11       	cpse	r24, r1
    1094:	2f c0       	rjmp	.+94     	; 0x10f4 <xTaskResumeAll+0x8e>
    1096:	5d c0       	rjmp	.+186    	; 0x1152 <xTaskResumeAll+0xec>
    1098:	d7 01       	movw	r26, r14
    109a:	15 96       	adiw	r26, 0x05	; 5
    109c:	ed 91       	ld	r30, X+
    109e:	fc 91       	ld	r31, X
    10a0:	16 97       	sbiw	r26, 0x06	; 6
    10a2:	c6 81       	ldd	r28, Z+6	; 0x06
    10a4:	d7 81       	ldd	r29, Z+7	; 0x07
    10a6:	ce 01       	movw	r24, r28
    10a8:	0c 96       	adiw	r24, 0x0c	; 12
    10aa:	01 da       	rcall	.-3070   	; 0x4ae <vListRemove>
    10ac:	8e 01       	movw	r16, r28
    10ae:	0e 5f       	subi	r16, 0xFE	; 254
    10b0:	1f 4f       	sbci	r17, 0xFF	; 255
    10b2:	c8 01       	movw	r24, r16
    10b4:	fc d9       	rcall	.-3080   	; 0x4ae <vListRemove>
    10b6:	8e 89       	ldd	r24, Y+22	; 0x16
    10b8:	90 91 1d 08 	lds	r25, 0x081D	; 0x80081d <uxTopReadyPriority>
    10bc:	98 17       	cp	r25, r24
    10be:	10 f4       	brcc	.+4      	; 0x10c4 <xTaskResumeAll+0x5e>
    10c0:	80 93 1d 08 	sts	0x081D, r24	; 0x80081d <uxTopReadyPriority>
    10c4:	90 e0       	ldi	r25, 0x00	; 0
    10c6:	9c 01       	movw	r18, r24
    10c8:	22 0f       	add	r18, r18
    10ca:	33 1f       	adc	r19, r19
    10cc:	22 0f       	add	r18, r18
    10ce:	33 1f       	adc	r19, r19
    10d0:	22 0f       	add	r18, r18
    10d2:	33 1f       	adc	r19, r19
    10d4:	82 0f       	add	r24, r18
    10d6:	93 1f       	adc	r25, r19
    10d8:	b8 01       	movw	r22, r16
    10da:	8f 5b       	subi	r24, 0xBF	; 191
    10dc:	97 4f       	sbci	r25, 0xF7	; 247
    10de:	85 d9       	rcall	.-3318   	; 0x3ea <vListInsertEnd>
    10e0:	e0 91 4a 08 	lds	r30, 0x084A	; 0x80084a <pxCurrentTCB>
    10e4:	f0 91 4b 08 	lds	r31, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
    10e8:	9e 89       	ldd	r25, Y+22	; 0x16
    10ea:	86 89       	ldd	r24, Z+22	; 0x16
    10ec:	98 17       	cp	r25, r24
    10ee:	58 f0       	brcs	.+22     	; 0x1106 <xTaskResumeAll+0xa0>
    10f0:	dc 2c       	mov	r13, r12
    10f2:	09 c0       	rjmp	.+18     	; 0x1106 <xTaskResumeAll+0xa0>
    10f4:	d1 2c       	mov	r13, r1
    10f6:	0f 2e       	mov	r0, r31
    10f8:	f2 e2       	ldi	r31, 0x22	; 34
    10fa:	ef 2e       	mov	r14, r31
    10fc:	f8 e0       	ldi	r31, 0x08	; 8
    10fe:	ff 2e       	mov	r15, r31
    1100:	f0 2d       	mov	r31, r0
    1102:	cc 24       	eor	r12, r12
    1104:	c3 94       	inc	r12
    1106:	f7 01       	movw	r30, r14
    1108:	80 81       	ld	r24, Z
    110a:	81 11       	cpse	r24, r1
    110c:	c5 cf       	rjmp	.-118    	; 0x1098 <xTaskResumeAll+0x32>
    110e:	80 91 1a 08 	lds	r24, 0x081A	; 0x80081a <uxMissedTicks>
    1112:	88 23       	and	r24, r24
    1114:	79 f0       	breq	.+30     	; 0x1134 <xTaskResumeAll+0xce>
    1116:	80 91 1a 08 	lds	r24, 0x081A	; 0x80081a <uxMissedTicks>
    111a:	88 23       	and	r24, r24
    111c:	91 f0       	breq	.+36     	; 0x1142 <xTaskResumeAll+0xdc>
    111e:	e2 de       	rcall	.-572    	; 0xee4 <vTaskIncrementTick>
    1120:	80 91 1a 08 	lds	r24, 0x081A	; 0x80081a <uxMissedTicks>
    1124:	81 50       	subi	r24, 0x01	; 1
    1126:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <uxMissedTicks>
    112a:	80 91 1a 08 	lds	r24, 0x081A	; 0x80081a <uxMissedTicks>
    112e:	81 11       	cpse	r24, r1
    1130:	f6 cf       	rjmp	.-20     	; 0x111e <xTaskResumeAll+0xb8>
    1132:	07 c0       	rjmp	.+14     	; 0x1142 <xTaskResumeAll+0xdc>
    1134:	f1 e0       	ldi	r31, 0x01	; 1
    1136:	df 16       	cp	r13, r31
    1138:	21 f0       	breq	.+8      	; 0x1142 <xTaskResumeAll+0xdc>
    113a:	80 91 19 08 	lds	r24, 0x0819	; 0x800819 <xMissedYield>
    113e:	81 30       	cpi	r24, 0x01	; 1
    1140:	39 f4       	brne	.+14     	; 0x1150 <xTaskResumeAll+0xea>
    1142:	10 92 19 08 	sts	0x0819, r1	; 0x800819 <xMissedYield>
    1146:	89 da       	rcall	.-2798   	; 0x65a <vPortYield>
    1148:	81 e0       	ldi	r24, 0x01	; 1
    114a:	03 c0       	rjmp	.+6      	; 0x1152 <xTaskResumeAll+0xec>
    114c:	80 e0       	ldi	r24, 0x00	; 0
    114e:	01 c0       	rjmp	.+2      	; 0x1152 <xTaskResumeAll+0xec>
    1150:	80 e0       	ldi	r24, 0x00	; 0
    1152:	0f 90       	pop	r0
    1154:	0f be       	out	0x3f, r0	; 63
    1156:	df 91       	pop	r29
    1158:	cf 91       	pop	r28
    115a:	1f 91       	pop	r17
    115c:	0f 91       	pop	r16
    115e:	ff 90       	pop	r15
    1160:	ef 90       	pop	r14
    1162:	df 90       	pop	r13
    1164:	cf 90       	pop	r12
    1166:	08 95       	ret

00001168 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1168:	cf 93       	push	r28
    116a:	df 93       	push	r29
    116c:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    116e:	89 2b       	or	r24, r25
    1170:	91 f0       	breq	.+36     	; 0x1196 <vTaskDelay+0x2e>
		{
			vTaskSuspendAll();
    1172:	b2 de       	rcall	.-668    	; 0xed8 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1174:	80 91 1f 08 	lds	r24, 0x081F	; 0x80081f <xTickCount>
    1178:	90 91 20 08 	lds	r25, 0x0820	; 0x800820 <xTickCount+0x1>
    117c:	c8 0f       	add	r28, r24
    117e:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1180:	80 91 4a 08 	lds	r24, 0x084A	; 0x80084a <pxCurrentTCB>
    1184:	90 91 4b 08 	lds	r25, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
    1188:	02 96       	adiw	r24, 0x02	; 2
    118a:	91 d9       	rcall	.-3294   	; 0x4ae <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    118c:	ce 01       	movw	r24, r28
    118e:	65 dd       	rcall	.-1334   	; 0xc5a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1190:	6a df       	rcall	.-300    	; 0x1066 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1192:	81 11       	cpse	r24, r1
    1194:	01 c0       	rjmp	.+2      	; 0x1198 <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
    1196:	61 da       	rcall	.-2878   	; 0x65a <vPortYield>
    1198:	df 91       	pop	r29
		}
	}
    119a:	cf 91       	pop	r28
    119c:	08 95       	ret

0000119e <vTaskSwitchContext>:
    119e:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <uxSchedulerSuspended>
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    11a2:	81 11       	cpse	r24, r1
    11a4:	13 c0       	rjmp	.+38     	; 0x11cc <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    11a6:	80 91 1d 08 	lds	r24, 0x081D	; 0x80081d <uxTopReadyPriority>
    11aa:	90 e0       	ldi	r25, 0x00	; 0
    11ac:	fc 01       	movw	r30, r24
    11ae:	ee 0f       	add	r30, r30
    11b0:	ff 1f       	adc	r31, r31
    11b2:	ee 0f       	add	r30, r30
    11b4:	ff 1f       	adc	r31, r31
    11b6:	ee 0f       	add	r30, r30
    11b8:	ff 1f       	adc	r31, r31
    11ba:	8e 0f       	add	r24, r30
    11bc:	9f 1f       	adc	r25, r31
    11be:	fc 01       	movw	r30, r24
    11c0:	ef 5b       	subi	r30, 0xBF	; 191
    11c2:	f7 4f       	sbci	r31, 0xF7	; 247
    11c4:	80 81       	ld	r24, Z
    11c6:	88 23       	and	r24, r24
    11c8:	29 f0       	breq	.+10     	; 0x11d4 <vTaskSwitchContext+0x36>
    11ca:	1b c0       	rjmp	.+54     	; 0x1202 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    11cc:	81 e0       	ldi	r24, 0x01	; 1
    11ce:	80 93 19 08 	sts	0x0819, r24	; 0x800819 <xMissedYield>
    11d2:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    11d4:	80 91 1d 08 	lds	r24, 0x081D	; 0x80081d <uxTopReadyPriority>
    11d8:	81 50       	subi	r24, 0x01	; 1
    11da:	80 93 1d 08 	sts	0x081D, r24	; 0x80081d <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    11de:	80 91 1d 08 	lds	r24, 0x081D	; 0x80081d <uxTopReadyPriority>
    11e2:	90 e0       	ldi	r25, 0x00	; 0
    11e4:	fc 01       	movw	r30, r24
    11e6:	ee 0f       	add	r30, r30
    11e8:	ff 1f       	adc	r31, r31
    11ea:	ee 0f       	add	r30, r30
    11ec:	ff 1f       	adc	r31, r31
    11ee:	ee 0f       	add	r30, r30
    11f0:	ff 1f       	adc	r31, r31
    11f2:	8e 0f       	add	r24, r30
    11f4:	9f 1f       	adc	r25, r31
    11f6:	fc 01       	movw	r30, r24
    11f8:	ef 5b       	subi	r30, 0xBF	; 191
    11fa:	f7 4f       	sbci	r31, 0xF7	; 247
    11fc:	80 81       	ld	r24, Z
    11fe:	88 23       	and	r24, r24
    1200:	49 f3       	breq	.-46     	; 0x11d4 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1202:	80 91 1d 08 	lds	r24, 0x081D	; 0x80081d <uxTopReadyPriority>
    1206:	90 e0       	ldi	r25, 0x00	; 0
    1208:	9c 01       	movw	r18, r24
    120a:	22 0f       	add	r18, r18
    120c:	33 1f       	adc	r19, r19
    120e:	22 0f       	add	r18, r18
    1210:	33 1f       	adc	r19, r19
    1212:	22 0f       	add	r18, r18
    1214:	33 1f       	adc	r19, r19
    1216:	28 0f       	add	r18, r24
    1218:	39 1f       	adc	r19, r25
    121a:	d9 01       	movw	r26, r18
    121c:	af 5b       	subi	r26, 0xBF	; 191
    121e:	b7 4f       	sbci	r27, 0xF7	; 247
    1220:	11 96       	adiw	r26, 0x01	; 1
    1222:	ed 91       	ld	r30, X+
    1224:	fc 91       	ld	r31, X
    1226:	12 97       	sbiw	r26, 0x02	; 2
    1228:	02 80       	ldd	r0, Z+2	; 0x02
    122a:	f3 81       	ldd	r31, Z+3	; 0x03
    122c:	e0 2d       	mov	r30, r0
    122e:	12 96       	adiw	r26, 0x02	; 2
    1230:	fc 93       	st	X, r31
    1232:	ee 93       	st	-X, r30
    1234:	11 97       	sbiw	r26, 0x01	; 1
    1236:	2c 5b       	subi	r18, 0xBC	; 188
    1238:	37 4f       	sbci	r19, 0xF7	; 247
    123a:	e2 17       	cp	r30, r18
    123c:	f3 07       	cpc	r31, r19
    123e:	29 f4       	brne	.+10     	; 0x124a <vTaskSwitchContext+0xac>
    1240:	22 81       	ldd	r18, Z+2	; 0x02
    1242:	33 81       	ldd	r19, Z+3	; 0x03
    1244:	fd 01       	movw	r30, r26
    1246:	32 83       	std	Z+2, r19	; 0x02
    1248:	21 83       	std	Z+1, r18	; 0x01
    124a:	fc 01       	movw	r30, r24
    124c:	ee 0f       	add	r30, r30
    124e:	ff 1f       	adc	r31, r31
    1250:	ee 0f       	add	r30, r30
    1252:	ff 1f       	adc	r31, r31
    1254:	ee 0f       	add	r30, r30
    1256:	ff 1f       	adc	r31, r31
    1258:	8e 0f       	add	r24, r30
    125a:	9f 1f       	adc	r25, r31
    125c:	fc 01       	movw	r30, r24
    125e:	ef 5b       	subi	r30, 0xBF	; 191
    1260:	f7 4f       	sbci	r31, 0xF7	; 247
    1262:	01 80       	ldd	r0, Z+1	; 0x01
    1264:	f2 81       	ldd	r31, Z+2	; 0x02
    1266:	e0 2d       	mov	r30, r0
    1268:	86 81       	ldd	r24, Z+6	; 0x06
    126a:	97 81       	ldd	r25, Z+7	; 0x07
    126c:	90 93 4b 08 	sts	0x084B, r25	; 0x80084b <pxCurrentTCB+0x1>
    1270:	80 93 4a 08 	sts	0x084A, r24	; 0x80084a <pxCurrentTCB>
    1274:	08 95       	ret

00001276 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1276:	cf 93       	push	r28
    1278:	df 93       	push	r29
    127a:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    127c:	60 91 4a 08 	lds	r22, 0x084A	; 0x80084a <pxCurrentTCB>
    1280:	70 91 4b 08 	lds	r23, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
    1284:	64 5f       	subi	r22, 0xF4	; 244
    1286:	7f 4f       	sbci	r23, 0xFF	; 255
    1288:	d7 d8       	rcall	.-3666   	; 0x438 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    128a:	80 91 4a 08 	lds	r24, 0x084A	; 0x80084a <pxCurrentTCB>
    128e:	90 91 4b 08 	lds	r25, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
    1292:	02 96       	adiw	r24, 0x02	; 2
    1294:	0c d9       	rcall	.-3560   	; 0x4ae <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1296:	80 91 1f 08 	lds	r24, 0x081F	; 0x80081f <xTickCount>
    129a:	90 91 20 08 	lds	r25, 0x0820	; 0x800820 <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    129e:	8c 0f       	add	r24, r28
    12a0:	9d 1f       	adc	r25, r29
    12a2:	db dc       	rcall	.-1610   	; 0xc5a <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    12a4:	df 91       	pop	r29
    12a6:	cf 91       	pop	r28
    12a8:	08 95       	ret

000012aa <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    12aa:	0f 93       	push	r16
    12ac:	1f 93       	push	r17
    12ae:	cf 93       	push	r28
    12b0:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    12b2:	dc 01       	movw	r26, r24
    12b4:	15 96       	adiw	r26, 0x05	; 5
    12b6:	ed 91       	ld	r30, X+
    12b8:	fc 91       	ld	r31, X
    12ba:	16 97       	sbiw	r26, 0x06	; 6
    12bc:	c6 81       	ldd	r28, Z+6	; 0x06
    12be:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    12c0:	8e 01       	movw	r16, r28
    12c2:	04 5f       	subi	r16, 0xF4	; 244
    12c4:	1f 4f       	sbci	r17, 0xFF	; 255
    12c6:	c8 01       	movw	r24, r16
    12c8:	f2 d8       	rcall	.-3612   	; 0x4ae <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    12ca:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <uxSchedulerSuspended>
    12ce:	81 11       	cpse	r24, r1
    12d0:	1a c0       	rjmp	.+52     	; 0x1306 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    12d2:	0a 50       	subi	r16, 0x0A	; 10
    12d4:	11 09       	sbc	r17, r1
    12d6:	c8 01       	movw	r24, r16
    12d8:	ea d8       	rcall	.-3628   	; 0x4ae <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    12da:	8e 89       	ldd	r24, Y+22	; 0x16
    12dc:	90 91 1d 08 	lds	r25, 0x081D	; 0x80081d <uxTopReadyPriority>
    12e0:	98 17       	cp	r25, r24
    12e2:	10 f4       	brcc	.+4      	; 0x12e8 <xTaskRemoveFromEventList+0x3e>
    12e4:	80 93 1d 08 	sts	0x081D, r24	; 0x80081d <uxTopReadyPriority>
    12e8:	90 e0       	ldi	r25, 0x00	; 0
    12ea:	9c 01       	movw	r18, r24
    12ec:	22 0f       	add	r18, r18
    12ee:	33 1f       	adc	r19, r19
    12f0:	22 0f       	add	r18, r18
    12f2:	33 1f       	adc	r19, r19
    12f4:	22 0f       	add	r18, r18
    12f6:	33 1f       	adc	r19, r19
    12f8:	82 0f       	add	r24, r18
    12fa:	93 1f       	adc	r25, r19
    12fc:	b8 01       	movw	r22, r16
    12fe:	8f 5b       	subi	r24, 0xBF	; 191
    1300:	97 4f       	sbci	r25, 0xF7	; 247
    1302:	73 d8       	rcall	.-3866   	; 0x3ea <vListInsertEnd>
    1304:	04 c0       	rjmp	.+8      	; 0x130e <xTaskRemoveFromEventList+0x64>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1306:	b8 01       	movw	r22, r16
    1308:	82 e2       	ldi	r24, 0x22	; 34
    130a:	98 e0       	ldi	r25, 0x08	; 8
    130c:	6e d8       	rcall	.-3876   	; 0x3ea <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    130e:	e0 91 4a 08 	lds	r30, 0x084A	; 0x80084a <pxCurrentTCB>
    1312:	f0 91 4b 08 	lds	r31, 0x084B	; 0x80084b <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1316:	81 e0       	ldi	r24, 0x01	; 1
    1318:	2e 89       	ldd	r18, Y+22	; 0x16
    131a:	96 89       	ldd	r25, Z+22	; 0x16
    131c:	29 17       	cp	r18, r25
    131e:	08 f4       	brcc	.+2      	; 0x1322 <xTaskRemoveFromEventList+0x78>
    1320:	80 e0       	ldi	r24, 0x00	; 0
}
    1322:	df 91       	pop	r29
    1324:	cf 91       	pop	r28
    1326:	1f 91       	pop	r17
    1328:	0f 91       	pop	r16
    132a:	08 95       	ret

0000132c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    132c:	20 91 18 08 	lds	r18, 0x0818	; 0x800818 <xNumOfOverflows>
    1330:	fc 01       	movw	r30, r24
    1332:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1334:	20 91 1f 08 	lds	r18, 0x081F	; 0x80081f <xTickCount>
    1338:	30 91 20 08 	lds	r19, 0x0820	; 0x800820 <xTickCount+0x1>
    133c:	32 83       	std	Z+2, r19	; 0x02
    133e:	21 83       	std	Z+1, r18	; 0x01
    1340:	08 95       	ret

00001342 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1342:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1344:	0f b6       	in	r0, 0x3f	; 63
    1346:	f8 94       	cli
    1348:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    134a:	80 91 18 08 	lds	r24, 0x0818	; 0x800818 <xNumOfOverflows>
    134e:	90 81       	ld	r25, Z
    1350:	98 17       	cp	r25, r24
    1352:	49 f0       	breq	.+18     	; 0x1366 <xTaskCheckForTimeOut+0x24>
    1354:	80 91 1f 08 	lds	r24, 0x081F	; 0x80081f <xTickCount>
    1358:	90 91 20 08 	lds	r25, 0x0820	; 0x800820 <xTickCount+0x1>
    135c:	21 81       	ldd	r18, Z+1	; 0x01
    135e:	32 81       	ldd	r19, Z+2	; 0x02
    1360:	82 17       	cp	r24, r18
    1362:	93 07       	cpc	r25, r19
    1364:	f0 f4       	brcc	.+60     	; 0x13a2 <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1366:	80 91 1f 08 	lds	r24, 0x081F	; 0x80081f <xTickCount>
    136a:	90 91 20 08 	lds	r25, 0x0820	; 0x800820 <xTickCount+0x1>
    136e:	41 81       	ldd	r20, Z+1	; 0x01
    1370:	52 81       	ldd	r21, Z+2	; 0x02
    1372:	db 01       	movw	r26, r22
    1374:	2d 91       	ld	r18, X+
    1376:	3c 91       	ld	r19, X
    1378:	11 97       	sbiw	r26, 0x01	; 1
    137a:	84 1b       	sub	r24, r20
    137c:	95 0b       	sbc	r25, r21
    137e:	82 17       	cp	r24, r18
    1380:	93 07       	cpc	r25, r19
    1382:	88 f4       	brcc	.+34     	; 0x13a6 <xTaskCheckForTimeOut+0x64>
    1384:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1386:	e0 91 1f 08 	lds	r30, 0x081F	; 0x80081f <xTickCount>
    138a:	f0 91 20 08 	lds	r31, 0x0820	; 0x800820 <xTickCount+0x1>
    138e:	bf 01       	movw	r22, r30
    1390:	64 1b       	sub	r22, r20
    1392:	75 0b       	sbc	r23, r21
    1394:	26 1b       	sub	r18, r22
    1396:	37 0b       	sbc	r19, r23
    1398:	2d 93       	st	X+, r18
    139a:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    139c:	c7 df       	rcall	.-114    	; 0x132c <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    139e:	80 e0       	ldi	r24, 0x00	; 0
    13a0:	03 c0       	rjmp	.+6      	; 0x13a8 <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    13a2:	81 e0       	ldi	r24, 0x01	; 1
    13a4:	01 c0       	rjmp	.+2      	; 0x13a8 <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    13a6:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    13a8:	0f 90       	pop	r0
    13aa:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    13ac:	08 95       	ret

000013ae <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    13ae:	81 e0       	ldi	r24, 0x01	; 1
    13b0:	80 93 19 08 	sts	0x0819, r24	; 0x800819 <xMissedYield>
    13b4:	08 95       	ret

000013b6 <__udivmodsi4>:
    13b6:	a1 e2       	ldi	r26, 0x21	; 33
    13b8:	1a 2e       	mov	r1, r26
    13ba:	aa 1b       	sub	r26, r26
    13bc:	bb 1b       	sub	r27, r27
    13be:	fd 01       	movw	r30, r26
    13c0:	0d c0       	rjmp	.+26     	; 0x13dc <__udivmodsi4_ep>

000013c2 <__udivmodsi4_loop>:
    13c2:	aa 1f       	adc	r26, r26
    13c4:	bb 1f       	adc	r27, r27
    13c6:	ee 1f       	adc	r30, r30
    13c8:	ff 1f       	adc	r31, r31
    13ca:	a2 17       	cp	r26, r18
    13cc:	b3 07       	cpc	r27, r19
    13ce:	e4 07       	cpc	r30, r20
    13d0:	f5 07       	cpc	r31, r21
    13d2:	20 f0       	brcs	.+8      	; 0x13dc <__udivmodsi4_ep>
    13d4:	a2 1b       	sub	r26, r18
    13d6:	b3 0b       	sbc	r27, r19
    13d8:	e4 0b       	sbc	r30, r20
    13da:	f5 0b       	sbc	r31, r21

000013dc <__udivmodsi4_ep>:
    13dc:	66 1f       	adc	r22, r22
    13de:	77 1f       	adc	r23, r23
    13e0:	88 1f       	adc	r24, r24
    13e2:	99 1f       	adc	r25, r25
    13e4:	1a 94       	dec	r1
    13e6:	69 f7       	brne	.-38     	; 0x13c2 <__udivmodsi4_loop>
    13e8:	60 95       	com	r22
    13ea:	70 95       	com	r23
    13ec:	80 95       	com	r24
    13ee:	90 95       	com	r25
    13f0:	9b 01       	movw	r18, r22
    13f2:	ac 01       	movw	r20, r24
    13f4:	bd 01       	movw	r22, r26
    13f6:	cf 01       	movw	r24, r30
    13f8:	08 95       	ret

000013fa <memcpy>:
    13fa:	fb 01       	movw	r30, r22
    13fc:	dc 01       	movw	r26, r24
    13fe:	02 c0       	rjmp	.+4      	; 0x1404 <memcpy+0xa>
    1400:	01 90       	ld	r0, Z+
    1402:	0d 92       	st	X+, r0
    1404:	41 50       	subi	r20, 0x01	; 1
    1406:	50 40       	sbci	r21, 0x00	; 0
    1408:	d8 f7       	brcc	.-10     	; 0x1400 <memcpy+0x6>
    140a:	08 95       	ret

0000140c <memset>:
    140c:	dc 01       	movw	r26, r24
    140e:	01 c0       	rjmp	.+2      	; 0x1412 <memset+0x6>
    1410:	6d 93       	st	X+, r22
    1412:	41 50       	subi	r20, 0x01	; 1
    1414:	50 40       	sbci	r21, 0x00	; 0
    1416:	e0 f7       	brcc	.-8      	; 0x1410 <memset+0x4>
    1418:	08 95       	ret

0000141a <strncpy>:
    141a:	fb 01       	movw	r30, r22
    141c:	dc 01       	movw	r26, r24
    141e:	41 50       	subi	r20, 0x01	; 1
    1420:	50 40       	sbci	r21, 0x00	; 0
    1422:	48 f0       	brcs	.+18     	; 0x1436 <strncpy+0x1c>
    1424:	01 90       	ld	r0, Z+
    1426:	0d 92       	st	X+, r0
    1428:	00 20       	and	r0, r0
    142a:	c9 f7       	brne	.-14     	; 0x141e <strncpy+0x4>
    142c:	01 c0       	rjmp	.+2      	; 0x1430 <strncpy+0x16>
    142e:	1d 92       	st	X+, r1
    1430:	41 50       	subi	r20, 0x01	; 1
    1432:	50 40       	sbci	r21, 0x00	; 0
    1434:	e0 f7       	brcc	.-8      	; 0x142e <strncpy+0x14>
    1436:	08 95       	ret

00001438 <__itoa_ncheck>:
    1438:	bb 27       	eor	r27, r27
    143a:	4a 30       	cpi	r20, 0x0A	; 10
    143c:	31 f4       	brne	.+12     	; 0x144a <__itoa_ncheck+0x12>
    143e:	99 23       	and	r25, r25
    1440:	22 f4       	brpl	.+8      	; 0x144a <__itoa_ncheck+0x12>
    1442:	bd e2       	ldi	r27, 0x2D	; 45
    1444:	90 95       	com	r25
    1446:	81 95       	neg	r24
    1448:	9f 4f       	sbci	r25, 0xFF	; 255
    144a:	01 c0       	rjmp	.+2      	; 0x144e <__utoa_common>

0000144c <__utoa_ncheck>:
    144c:	bb 27       	eor	r27, r27

0000144e <__utoa_common>:
    144e:	fb 01       	movw	r30, r22
    1450:	55 27       	eor	r21, r21
    1452:	aa 27       	eor	r26, r26
    1454:	88 0f       	add	r24, r24
    1456:	99 1f       	adc	r25, r25
    1458:	aa 1f       	adc	r26, r26
    145a:	a4 17       	cp	r26, r20
    145c:	10 f0       	brcs	.+4      	; 0x1462 <__utoa_common+0x14>
    145e:	a4 1b       	sub	r26, r20
    1460:	83 95       	inc	r24
    1462:	50 51       	subi	r21, 0x10	; 16
    1464:	b9 f7       	brne	.-18     	; 0x1454 <__utoa_common+0x6>
    1466:	a0 5d       	subi	r26, 0xD0	; 208
    1468:	aa 33       	cpi	r26, 0x3A	; 58
    146a:	08 f0       	brcs	.+2      	; 0x146e <__utoa_common+0x20>
    146c:	a9 5d       	subi	r26, 0xD9	; 217
    146e:	a1 93       	st	Z+, r26
    1470:	00 97       	sbiw	r24, 0x00	; 0
    1472:	79 f7       	brne	.-34     	; 0x1452 <__utoa_common+0x4>
    1474:	b1 11       	cpse	r27, r1
    1476:	b1 93       	st	Z+, r27
    1478:	11 92       	st	Z+, r1
    147a:	cb 01       	movw	r24, r22
    147c:	00 c0       	rjmp	.+0      	; 0x147e <strrev>

0000147e <strrev>:
    147e:	dc 01       	movw	r26, r24
    1480:	fc 01       	movw	r30, r24
    1482:	67 2f       	mov	r22, r23
    1484:	71 91       	ld	r23, Z+
    1486:	77 23       	and	r23, r23
    1488:	e1 f7       	brne	.-8      	; 0x1482 <strrev+0x4>
    148a:	32 97       	sbiw	r30, 0x02	; 2
    148c:	04 c0       	rjmp	.+8      	; 0x1496 <strrev+0x18>
    148e:	7c 91       	ld	r23, X
    1490:	6d 93       	st	X+, r22
    1492:	70 83       	st	Z, r23
    1494:	62 91       	ld	r22, -Z
    1496:	ae 17       	cp	r26, r30
    1498:	bf 07       	cpc	r27, r31
    149a:	c8 f3       	brcs	.-14     	; 0x148e <strrev+0x10>
    149c:	08 95       	ret

0000149e <_exit>:
    149e:	f8 94       	cli

000014a0 <__stop_program>:
    14a0:	ff cf       	rjmp	.-2      	; 0x14a0 <__stop_program>
