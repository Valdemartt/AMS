
Flappy_2.0.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000014  00800200  00000b44  00000bd8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000b44  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000014  00800214  00800214  00000bec  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000bec  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000c1c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002b8  00000000  00000000  00000c5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000067ff  00000000  00000000  00000f14  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001b15  00000000  00000000  00007713  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000152c  00000000  00000000  00009228  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000008c8  00000000  00000000  0000a754  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001612  00000000  00000000  0000b01c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000029dc  00000000  00000000  0000c62e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000258  00000000  00000000  0000f00a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	72 c0       	rjmp	.+228    	; 0xe6 <__ctors_end>
   2:	00 00       	nop
   4:	9e c0       	rjmp	.+316    	; 0x142 <__bad_interrupt>
   6:	00 00       	nop
   8:	9c c0       	rjmp	.+312    	; 0x142 <__bad_interrupt>
   a:	00 00       	nop
   c:	9a c0       	rjmp	.+308    	; 0x142 <__bad_interrupt>
   e:	00 00       	nop
  10:	98 c0       	rjmp	.+304    	; 0x142 <__bad_interrupt>
  12:	00 00       	nop
  14:	a5 c1       	rjmp	.+842    	; 0x360 <__vector_5>
  16:	00 00       	nop
  18:	94 c0       	rjmp	.+296    	; 0x142 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	92 c0       	rjmp	.+292    	; 0x142 <__bad_interrupt>
  1e:	00 00       	nop
  20:	90 c0       	rjmp	.+288    	; 0x142 <__bad_interrupt>
  22:	00 00       	nop
  24:	8e c0       	rjmp	.+284    	; 0x142 <__bad_interrupt>
  26:	00 00       	nop
  28:	8c c0       	rjmp	.+280    	; 0x142 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	8a c0       	rjmp	.+276    	; 0x142 <__bad_interrupt>
  2e:	00 00       	nop
  30:	88 c0       	rjmp	.+272    	; 0x142 <__bad_interrupt>
  32:	00 00       	nop
  34:	86 c0       	rjmp	.+268    	; 0x142 <__bad_interrupt>
  36:	00 00       	nop
  38:	84 c0       	rjmp	.+264    	; 0x142 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	82 c0       	rjmp	.+260    	; 0x142 <__bad_interrupt>
  3e:	00 00       	nop
  40:	80 c0       	rjmp	.+256    	; 0x142 <__bad_interrupt>
  42:	00 00       	nop
  44:	c4 c1       	rjmp	.+904    	; 0x3ce <__vector_17>
  46:	00 00       	nop
  48:	7c c0       	rjmp	.+248    	; 0x142 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	7a c0       	rjmp	.+244    	; 0x142 <__bad_interrupt>
  4e:	00 00       	nop
  50:	78 c0       	rjmp	.+240    	; 0x142 <__bad_interrupt>
  52:	00 00       	nop
  54:	76 c0       	rjmp	.+236    	; 0x142 <__bad_interrupt>
  56:	00 00       	nop
  58:	74 c0       	rjmp	.+232    	; 0x142 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	72 c0       	rjmp	.+228    	; 0x142 <__bad_interrupt>
  5e:	00 00       	nop
  60:	70 c0       	rjmp	.+224    	; 0x142 <__bad_interrupt>
  62:	00 00       	nop
  64:	6e c0       	rjmp	.+220    	; 0x142 <__bad_interrupt>
  66:	00 00       	nop
  68:	6c c0       	rjmp	.+216    	; 0x142 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	6a c0       	rjmp	.+212    	; 0x142 <__bad_interrupt>
  6e:	00 00       	nop
  70:	68 c0       	rjmp	.+208    	; 0x142 <__bad_interrupt>
  72:	00 00       	nop
  74:	66 c0       	rjmp	.+204    	; 0x142 <__bad_interrupt>
  76:	00 00       	nop
  78:	64 c0       	rjmp	.+200    	; 0x142 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	62 c0       	rjmp	.+196    	; 0x142 <__bad_interrupt>
  7e:	00 00       	nop
  80:	60 c0       	rjmp	.+192    	; 0x142 <__bad_interrupt>
  82:	00 00       	nop
  84:	5e c0       	rjmp	.+188    	; 0x142 <__bad_interrupt>
  86:	00 00       	nop
  88:	5c c0       	rjmp	.+184    	; 0x142 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	5a c0       	rjmp	.+180    	; 0x142 <__bad_interrupt>
  8e:	00 00       	nop
  90:	58 c0       	rjmp	.+176    	; 0x142 <__bad_interrupt>
  92:	00 00       	nop
  94:	56 c0       	rjmp	.+172    	; 0x142 <__bad_interrupt>
  96:	00 00       	nop
  98:	54 c0       	rjmp	.+168    	; 0x142 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	52 c0       	rjmp	.+164    	; 0x142 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	50 c0       	rjmp	.+160    	; 0x142 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	4e c0       	rjmp	.+156    	; 0x142 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	4c c0       	rjmp	.+152    	; 0x142 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	4a c0       	rjmp	.+148    	; 0x142 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	48 c0       	rjmp	.+144    	; 0x142 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	46 c0       	rjmp	.+140    	; 0x142 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	44 c0       	rjmp	.+136    	; 0x142 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	42 c0       	rjmp	.+132    	; 0x142 <__bad_interrupt>
  be:	00 00       	nop
  c0:	40 c0       	rjmp	.+128    	; 0x142 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	3e c0       	rjmp	.+124    	; 0x142 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	3c c0       	rjmp	.+120    	; 0x142 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	3a c0       	rjmp	.+116    	; 0x142 <__bad_interrupt>
  ce:	00 00       	nop
  d0:	38 c0       	rjmp	.+112    	; 0x142 <__bad_interrupt>
  d2:	00 00       	nop
  d4:	36 c0       	rjmp	.+108    	; 0x142 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	34 c0       	rjmp	.+104    	; 0x142 <__bad_interrupt>
  da:	00 00       	nop
  dc:	32 c0       	rjmp	.+100    	; 0x142 <__bad_interrupt>
  de:	00 00       	nop
  e0:	30 c0       	rjmp	.+96     	; 0x142 <__bad_interrupt>
	...

000000e4 <__ctors_start>:
  e4:	18 02       	muls	r17, r24

000000e6 <__ctors_end>:
  e6:	11 24       	eor	r1, r1
  e8:	1f be       	out	0x3f, r1	; 63
  ea:	cf ef       	ldi	r28, 0xFF	; 255
  ec:	d1 e2       	ldi	r29, 0x21	; 33
  ee:	de bf       	out	0x3e, r29	; 62
  f0:	cd bf       	out	0x3d, r28	; 61
  f2:	00 e0       	ldi	r16, 0x00	; 0
  f4:	0c bf       	out	0x3c, r16	; 60

000000f6 <__do_copy_data>:
  f6:	12 e0       	ldi	r17, 0x02	; 2
  f8:	a0 e0       	ldi	r26, 0x00	; 0
  fa:	b2 e0       	ldi	r27, 0x02	; 2
  fc:	e4 e4       	ldi	r30, 0x44	; 68
  fe:	fb e0       	ldi	r31, 0x0B	; 11
 100:	00 e0       	ldi	r16, 0x00	; 0
 102:	0b bf       	out	0x3b, r16	; 59
 104:	02 c0       	rjmp	.+4      	; 0x10a <__do_copy_data+0x14>
 106:	07 90       	elpm	r0, Z+
 108:	0d 92       	st	X+, r0
 10a:	a4 31       	cpi	r26, 0x14	; 20
 10c:	b1 07       	cpc	r27, r17
 10e:	d9 f7       	brne	.-10     	; 0x106 <__do_copy_data+0x10>

00000110 <__do_clear_bss>:
 110:	22 e0       	ldi	r18, 0x02	; 2
 112:	a4 e1       	ldi	r26, 0x14	; 20
 114:	b2 e0       	ldi	r27, 0x02	; 2
 116:	01 c0       	rjmp	.+2      	; 0x11a <.do_clear_bss_start>

00000118 <.do_clear_bss_loop>:
 118:	1d 92       	st	X+, r1

0000011a <.do_clear_bss_start>:
 11a:	a8 32       	cpi	r26, 0x28	; 40
 11c:	b2 07       	cpc	r27, r18
 11e:	e1 f7       	brne	.-8      	; 0x118 <.do_clear_bss_loop>

00000120 <__do_global_ctors>:
 120:	10 e0       	ldi	r17, 0x00	; 0
 122:	c3 e7       	ldi	r28, 0x73	; 115
 124:	d0 e0       	ldi	r29, 0x00	; 0
 126:	00 e0       	ldi	r16, 0x00	; 0
 128:	05 c0       	rjmp	.+10     	; 0x134 <__do_global_ctors+0x14>
 12a:	21 97       	sbiw	r28, 0x01	; 1
 12c:	01 09       	sbc	r16, r1
 12e:	80 2f       	mov	r24, r16
 130:	fe 01       	movw	r30, r28
 132:	cb d4       	rcall	.+2454   	; 0xaca <__tablejump2__>
 134:	c2 37       	cpi	r28, 0x72	; 114
 136:	d1 07       	cpc	r29, r17
 138:	80 e0       	ldi	r24, 0x00	; 0
 13a:	08 07       	cpc	r16, r24
 13c:	b1 f7       	brne	.-20     	; 0x12a <__do_global_ctors+0xa>
 13e:	69 d0       	rcall	.+210    	; 0x212 <main>
 140:	ff c4       	rjmp	.+2558   	; 0xb40 <_exit>

00000142 <__bad_interrupt>:
 142:	5e cf       	rjmp	.-324    	; 0x0 <__vectors>

00000144 <_ZN14GameControllerC1EP9TFTDriverP11TouchDriverlii>:
// default destructor
GameController::~GameController()
{
} //~GameController

GameController::GameController(TFTDriver *tftDriver, TouchDriver *touchDriver, long seed, int pipeWidth, int pipeGap)
 144:	4f 92       	push	r4
 146:	5f 92       	push	r5
 148:	6f 92       	push	r6
 14a:	7f 92       	push	r7
 14c:	8f 92       	push	r8
 14e:	9f 92       	push	r9
 150:	af 92       	push	r10
 152:	bf 92       	push	r11
 154:	cf 92       	push	r12
 156:	df 92       	push	r13
 158:	ef 92       	push	r14
 15a:	ff 92       	push	r15
 15c:	0f 93       	push	r16
 15e:	1f 93       	push	r17
 160:	cf 93       	push	r28
 162:	df 93       	push	r29
 164:	ec 01       	movw	r28, r24
 166:	4b 01       	movw	r8, r22
 168:	5a 01       	movw	r10, r20
 16a:	28 01       	movw	r4, r16
 16c:	39 01       	movw	r6, r18
 16e:	06 96       	adiw	r24, 0x06	; 6
 170:	48 d4       	rcall	.+2192   	; 0xa02 <_ZN8UIObjectC1Ev>
{
	_tftDriver = tftDriver;
 172:	99 82       	std	Y+1, r9	; 0x01
 174:	88 82       	st	Y, r8
	_touchDriver = touchDriver;
 176:	bb 82       	std	Y+3, r11	; 0x03
 178:	aa 82       	std	Y+2, r10	; 0x02
	_rngState = seed;
 17a:	49 8a       	std	Y+17, r4	; 0x11
 17c:	5a 8a       	std	Y+18, r5	; 0x12
 17e:	6b 8a       	std	Y+19, r6	; 0x13
 180:	7c 8a       	std	Y+20, r7	; 0x14
	_lastPipeOffset = 0;
 182:	1e 8a       	std	Y+22, r1	; 0x16
 184:	1d 8a       	std	Y+21, r1	; 0x15
	_pipeWidth = pipeWidth;
 186:	fa 8e       	std	Y+26, r15	; 0x1a
 188:	e9 8e       	std	Y+25, r14	; 0x19
	_pipeGap = pipeGap;
 18a:	d8 8e       	std	Y+24, r13	; 0x18
 18c:	cf 8a       	std	Y+23, r12	; 0x17
}
 18e:	df 91       	pop	r29
 190:	cf 91       	pop	r28
 192:	1f 91       	pop	r17
 194:	0f 91       	pop	r16
 196:	ff 90       	pop	r15
 198:	ef 90       	pop	r14
 19a:	df 90       	pop	r13
 19c:	cf 90       	pop	r12
 19e:	bf 90       	pop	r11
 1a0:	af 90       	pop	r10
 1a2:	9f 90       	pop	r9
 1a4:	8f 90       	pop	r8
 1a6:	7f 90       	pop	r7
 1a8:	6f 90       	pop	r6
 1aa:	5f 90       	pop	r5
 1ac:	4f 90       	pop	r4
 1ae:	08 95       	ret

000001b0 <_Z8SendCharc>:
	Tegn : Character for sending. 
*************************************************************************/
void SendChar(char Tegn)
{
  // Wait for transmitter register empty (ready for new character)
  while ( (UCSR0A & (1<<5)) == 0 )
 1b0:	e0 ec       	ldi	r30, 0xC0	; 192
 1b2:	f0 e0       	ldi	r31, 0x00	; 0
 1b4:	90 81       	ld	r25, Z
 1b6:	95 ff       	sbrs	r25, 5
 1b8:	fd cf       	rjmp	.-6      	; 0x1b4 <_Z8SendCharc+0x4>
  {}
  // Then send the character
  UDR0 = Tegn;
 1ba:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
 1be:	08 95       	ret

000001c0 <_Z10SendStringPc>:
Sends 0 terminated string.
Parameter:
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
 1c0:	cf 93       	push	r28
 1c2:	df 93       	push	r29
 1c4:	ec 01       	movw	r28, r24
  // Repeat until zero-termination
  while (*Streng != 0)
 1c6:	88 81       	ld	r24, Y
 1c8:	88 23       	and	r24, r24
 1ca:	29 f0       	breq	.+10     	; 0x1d6 <_Z10SendStringPc+0x16>
 1cc:	21 96       	adiw	r28, 0x01	; 1
  {
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
 1ce:	f0 df       	rcall	.-32     	; 0x1b0 <_Z8SendCharc>
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
  // Repeat until zero-termination
  while (*Streng != 0)
 1d0:	89 91       	ld	r24, Y+
 1d2:	81 11       	cpse	r24, r1
 1d4:	fc cf       	rjmp	.-8      	; 0x1ce <_Z10SendStringPc+0xe>
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    // Advance the pointer one step
    Streng++;
  }
}
 1d6:	df 91       	pop	r29
 1d8:	cf 91       	pop	r28
 1da:	08 95       	ret

000001dc <_Z11SendIntegeri>:
Makes use of the C standard library <stdlib.h>.
Parameter:
    Tal: The integer to be converted and sent. 
*************************************************************************/
void SendInteger(int Tal)
{
 1dc:	cf 93       	push	r28
 1de:	df 93       	push	r29
 1e0:	cd b7       	in	r28, 0x3d	; 61
 1e2:	de b7       	in	r29, 0x3e	; 62
 1e4:	27 97       	sbiw	r28, 0x07	; 7
 1e6:	0f b6       	in	r0, 0x3f	; 63
 1e8:	f8 94       	cli
 1ea:	de bf       	out	0x3e, r29	; 62
 1ec:	0f be       	out	0x3f, r0	; 63
 1ee:	cd bf       	out	0x3d, r28	; 61
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
 1f0:	4a e0       	ldi	r20, 0x0A	; 10
 1f2:	be 01       	movw	r22, r28
 1f4:	6f 5f       	subi	r22, 0xFF	; 255
 1f6:	7f 4f       	sbci	r23, 0xFF	; 255
 1f8:	70 d4       	rcall	.+2272   	; 0xada <__itoa_ncheck>
char array[7];
  // Convert the integer to an ASCII string (array), radix = 10 
  itoa(Tal, array, 10);
  // - then send the string
  SendString(array);
 1fa:	ce 01       	movw	r24, r28
 1fc:	01 96       	adiw	r24, 0x01	; 1
 1fe:	e0 df       	rcall	.-64     	; 0x1c0 <_Z10SendStringPc>
}
 200:	27 96       	adiw	r28, 0x07	; 7
 202:	0f b6       	in	r0, 0x3f	; 63
 204:	f8 94       	cli
 206:	de bf       	out	0x3e, r29	; 62
 208:	0f be       	out	0x3f, r0	; 63
 20a:	cd bf       	out	0x3d, r28	; 61
 20c:	df 91       	pop	r29
 20e:	cf 91       	pop	r28
 210:	08 95       	ret

00000212 <main>:

TouchDriver touchDriver(400, 400, 4095, 320, 240);
Position pos;

int main(void)
{	 
 212:	cf 93       	push	r28
 214:	df 93       	push	r29
 216:	cd b7       	in	r28, 0x3d	; 61
 218:	de b7       	in	r29, 0x3e	; 62
 21a:	c4 56       	subi	r28, 0x64	; 100
 21c:	d1 09       	sbc	r29, r1
 21e:	0f b6       	in	r0, 0x3f	; 63
 220:	f8 94       	cli
 222:	de bf       	out	0x3e, r29	; 62
 224:	0f be       	out	0x3f, r0	; 63
 226:	cd bf       	out	0x3d, r28	; 61
void InitUART(unsigned long BaudRate, unsigned char DataBit, char Parity)
{
  if ((BaudRate >= 300) && (BaudRate <= 115200) && (DataBit >=5) && (DataBit <= 8))
  { 
    // "Normal" clock, no multiprocessor mode (= default)
    UCSR0A = 0b00100000;
 228:	80 e2       	ldi	r24, 0x20	; 32
 22a:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    // No interrupts enabled
    // Receiver enabled
    // Transmitter enabled
    // No 9 bit operation
    UCSR0B = 0b00011000;	
 22e:	88 e1       	ldi	r24, 0x18	; 24
 230:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    // Asynchronous operation, 1 stop bit
    // Bit 2 and bit 1 controls the number of data bits
    UCSR0C = (DataBit-5)<<1;
 234:	86 e0       	ldi	r24, 0x06	; 6
 236:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
	if (Parity == 'E')
      UCSR0C |= 0b00100000;
    else if (Parity == 'O')	  
      UCSR0C |= 0b00110000;	
    // Set Baud Rate according to the parameter BaudRate:
    UBRR0 = XTAL/(16*BaudRate) - 1;
 23a:	87 e6       	ldi	r24, 0x67	; 103
 23c:	90 e0       	ldi	r25, 0x00	; 0
 23e:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
 242:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    //Main loop, skal håndtere hele spillet.
	//freeRTOS bør nok benyttes.
	InitUART(9600,8,'N');
	////_delay_ms(1000);
	touchDriver.InitTouch();
 246:	84 e1       	ldi	r24, 0x14	; 20
 248:	92 e0       	ldi	r25, 0x02	; 2
 24a:	71 d3       	rcall	.+1762   	; 0x92e <_ZN11TouchDriver9InitTouchEv>
	SendString("RST");
 24c:	80 e0       	ldi	r24, 0x00	; 0
 24e:	92 e0       	ldi	r25, 0x02	; 2
 250:	b7 df       	rcall	.-146    	; 0x1c0 <_Z10SendStringPc>
	UIObjectFactory factory = UIObjectFactory();
 252:	ce 01       	movw	r24, r28
 254:	01 96       	adiw	r24, 0x01	; 1
 256:	f5 d3       	rcall	.+2026   	; 0xa42 <_ZN15UIObjectFactoryC1Ev>
		color |= (red_enc<<12);
		_encodedColor = color;
	}
	Color(char red, char green, char blue)
	{
		_red = red;
 258:	8f ef       	ldi	r24, 0xFF	; 255
 25a:	8b 87       	std	Y+11, r24	; 0x0b
		_green = green;
 25c:	1c 86       	std	Y+12, r1	; 0x0c
		_blue = blue;
 25e:	1d 86       	std	Y+13, r1	; 0x0d
		
		unsigned int color = 0;
		color |= blue_enc;
		color |= (green_enc<<6);
		color |= (red_enc<<12);
		_encodedColor = color;
 260:	20 e0       	ldi	r18, 0x00	; 0
 262:	30 ef       	ldi	r19, 0xF0	; 240
 264:	39 8b       	std	Y+17, r19	; 0x11
 266:	28 8b       	std	Y+16, r18	; 0x10
		color |= (red_enc<<12);
		_encodedColor = color;
	}
	Color(char red, char green, char blue)
	{
		_red = red;
 268:	1a 8a       	std	Y+18, r1	; 0x12
		_green = green;
 26a:	8b 8b       	std	Y+19, r24	; 0x13
		_blue = blue;
 26c:	1c 8a       	std	Y+20, r1	; 0x14
		
		unsigned int color = 0;
		color |= blue_enc;
		color |= (green_enc<<6);
		color |= (red_enc<<12);
		_encodedColor = color;
 26e:	20 ec       	ldi	r18, 0xC0	; 192
 270:	3f e0       	ldi	r19, 0x0F	; 15
 272:	38 8f       	std	Y+24, r19	; 0x18
 274:	2f 8b       	std	Y+23, r18	; 0x17
		color |= (red_enc<<12);
		_encodedColor = color;
	}
	Color(char red, char green, char blue)
	{
		_red = red;
 276:	19 8e       	std	Y+25, r1	; 0x19
		_green = green;
 278:	1a 8e       	std	Y+26, r1	; 0x1a
		_blue = blue;
 27a:	8b 8f       	std	Y+27, r24	; 0x1b
		
		unsigned int color = 0;
		color |= blue_enc;
		color |= (green_enc<<6);
		color |= (red_enc<<12);
		_encodedColor = color;
 27c:	8f e1       	ldi	r24, 0x1F	; 31
 27e:	90 e0       	ldi	r25, 0x00	; 0
 280:	9f 8f       	std	Y+31, r25	; 0x1f
 282:	8e 8f       	std	Y+30, r24	; 0x1e
	Color Red(255, 0,0);
	Color Green(0, 255, 0);
	Color Blue(0, 0, 255);
	
	int _lastPipeOffset = 100;
	UIObject lowerPipe(290, _lastPipeOffset + 50, 240 - _lastPipeOffset - 50, 30, &Green);
 284:	5e 01       	movw	r10, r28
 286:	20 e2       	ldi	r18, 0x20	; 32
 288:	a2 0e       	add	r10, r18
 28a:	b1 1c       	adc	r11, r1
 28c:	ce 01       	movw	r24, r28
 28e:	42 96       	adiw	r24, 0x12	; 18
 290:	7c 01       	movw	r14, r24
 292:	0e e1       	ldi	r16, 0x1E	; 30
 294:	10 e0       	ldi	r17, 0x00	; 0
 296:	2a e5       	ldi	r18, 0x5A	; 90
 298:	30 e0       	ldi	r19, 0x00	; 0
 29a:	46 e9       	ldi	r20, 0x96	; 150
 29c:	50 e0       	ldi	r21, 0x00	; 0
 29e:	62 e2       	ldi	r22, 0x22	; 34
 2a0:	71 e0       	ldi	r23, 0x01	; 1
 2a2:	c5 01       	movw	r24, r10
 2a4:	95 d3       	rcall	.+1834   	; 0x9d0 <_ZN8UIObjectC1EiiiiP5Color>
	UIObject upperPipe(290, 0, 240 - 50 - _lastPipeOffset, 30, &Green);
 2a6:	6e 01       	movw	r12, r28
 2a8:	9a e2       	ldi	r25, 0x2A	; 42
 2aa:	c9 0e       	add	r12, r25
 2ac:	d1 1c       	adc	r13, r1
 2ae:	2a e5       	ldi	r18, 0x5A	; 90
 2b0:	30 e0       	ldi	r19, 0x00	; 0
 2b2:	40 e0       	ldi	r20, 0x00	; 0
 2b4:	50 e0       	ldi	r21, 0x00	; 0
 2b6:	62 e2       	ldi	r22, 0x22	; 34
 2b8:	71 e0       	ldi	r23, 0x01	; 1
 2ba:	c6 01       	movw	r24, r12
 2bc:	89 d3       	rcall	.+1810   	; 0x9d0 <_ZN8UIObjectC1EiiiiP5Color>
	UIObject * _pipes[2] =
	{
		&lowerPipe,
		&upperPipe
	};
 2be:	bd aa       	std	Y+53, r11	; 0x35
 2c0:	ac aa       	std	Y+52, r10	; 0x34
 2c2:	df aa       	std	Y+55, r13	; 0x37
 2c4:	ce aa       	std	Y+54, r12	; 0x36
	UIObject flappy = UIObject(0, 0, 0, 0, &Red);
 2c6:	ce 01       	movw	r24, r28
 2c8:	0b 96       	adiw	r24, 0x0b	; 11
 2ca:	7c 01       	movw	r14, r24
 2cc:	00 e0       	ldi	r16, 0x00	; 0
 2ce:	10 e0       	ldi	r17, 0x00	; 0
 2d0:	20 e0       	ldi	r18, 0x00	; 0
 2d2:	30 e0       	ldi	r19, 0x00	; 0
 2d4:	40 e0       	ldi	r20, 0x00	; 0
 2d6:	50 e0       	ldi	r21, 0x00	; 0
 2d8:	60 e0       	ldi	r22, 0x00	; 0
 2da:	70 e0       	ldi	r23, 0x00	; 0
 2dc:	8d 96       	adiw	r24, 0x2d	; 45
 2de:	78 d3       	rcall	.+1776   	; 0x9d0 <_ZN8UIObjectC1EiiiiP5Color>
	
	TFTDriver tftDriver(320, 240);
 2e0:	40 ef       	ldi	r20, 0xF0	; 240
 2e2:	50 e0       	ldi	r21, 0x00	; 0
 2e4:	60 e4       	ldi	r22, 0x40	; 64
 2e6:	71 e0       	ldi	r23, 0x01	; 1
 2e8:	ce 01       	movw	r24, r28
 2ea:	8e 5b       	subi	r24, 0xBE	; 190
 2ec:	9f 4f       	sbci	r25, 0xFF	; 255
	tftDriver.DisplayInit();
 2ee:	c8 d0       	rcall	.+400    	; 0x480 <_ZN9TFTDriverC1Eii>
 2f0:	ce 01       	movw	r24, r28
 2f2:	8e 5b       	subi	r24, 0xBE	; 190
 2f4:	9f 4f       	sbci	r25, 0xFF	; 255
	tftDriver.DrawBackground(&Blue);
 2f6:	23 d1       	rcall	.+582    	; 0x53e <_ZN9TFTDriver11DisplayInitEv>
 2f8:	be 01       	movw	r22, r28
 2fa:	67 5e       	subi	r22, 0xE7	; 231
 2fc:	7f 4f       	sbci	r23, 0xFF	; 255
 2fe:	ce 01       	movw	r24, r28
 300:	8e 5b       	subi	r24, 0xBE	; 190
 302:	9f 4f       	sbci	r25, 0xFF	; 255
 304:	14 d2       	rcall	.+1064   	; 0x72e <_ZN9TFTDriver14DrawBackgroundEP5Color>
	GameController game(&tftDriver, & touchDriver, 42, 30, 50);
 306:	0f 2e       	mov	r0, r31
 308:	f2 e3       	ldi	r31, 0x32	; 50
 30a:	cf 2e       	mov	r12, r31
 30c:	d1 2c       	mov	r13, r1
 30e:	f0 2d       	mov	r31, r0
 310:	0f 2e       	mov	r0, r31
 312:	fe e1       	ldi	r31, 0x1E	; 30
 314:	ef 2e       	mov	r14, r31
 316:	f1 2c       	mov	r15, r1
 318:	f0 2d       	mov	r31, r0
 31a:	0a e2       	ldi	r16, 0x2A	; 42
 31c:	10 e0       	ldi	r17, 0x00	; 0
 31e:	20 e0       	ldi	r18, 0x00	; 0
 320:	30 e0       	ldi	r19, 0x00	; 0
 322:	44 e1       	ldi	r20, 0x14	; 20
 324:	52 e0       	ldi	r21, 0x02	; 2
 326:	be 01       	movw	r22, r28
 328:	6e 5b       	subi	r22, 0xBE	; 190
 32a:	7f 4f       	sbci	r23, 0xFF	; 255
 32c:	ce 01       	movw	r24, r28
 32e:	8a 5b       	subi	r24, 0xBA	; 186
 330:	9f 4f       	sbci	r25, 0xFF	; 255
 332:	08 df       	rcall	.-496    	; 0x144 <_ZN14GameControllerC1EP9TFTDriverP11TouchDriverlii>
	//game.StartGame();
    while(true)
    {
		tftDriver.DrawGame(_pipes, sizeof(_pipes), &flappy);
 334:	9e 01       	movw	r18, r28
 336:	28 5c       	subi	r18, 0xC8	; 200
 338:	3f 4f       	sbci	r19, 0xFF	; 255
 33a:	44 e0       	ldi	r20, 0x04	; 4
 33c:	50 e0       	ldi	r21, 0x00	; 0
 33e:	be 01       	movw	r22, r28
 340:	6c 5c       	subi	r22, 0xCC	; 204
 342:	7f 4f       	sbci	r23, 0xFF	; 255
 344:	ce 01       	movw	r24, r28
 346:	8e 5b       	subi	r24, 0xBE	; 190
 348:	9f 4f       	sbci	r25, 0xFF	; 255
 34a:	6e d1       	rcall	.+732    	; 0x628 <_ZN9TFTDriver8DrawGameEPP8UIObjectiS1_>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 34c:	9f ef       	ldi	r25, 0xFF	; 255
 34e:	23 ed       	ldi	r18, 0xD3	; 211
 350:	80 e3       	ldi	r24, 0x30	; 48
 352:	91 50       	subi	r25, 0x01	; 1
 354:	20 40       	sbci	r18, 0x00	; 0
 356:	80 40       	sbci	r24, 0x00	; 0
 358:	e1 f7       	brne	.-8      	; 0x352 <main+0x140>
 35a:	00 c0       	rjmp	.+0      	; 0x35c <main+0x14a>
 35c:	00 00       	nop
 35e:	ea cf       	rjmp	.-44     	; 0x334 <main+0x122>

00000360 <__vector_5>:
		//_delay_ms(1000);
    }
}

ISR(INT4_vect)
{
 360:	1f 92       	push	r1
 362:	0f 92       	push	r0
 364:	0f b6       	in	r0, 0x3f	; 63
 366:	0f 92       	push	r0
 368:	11 24       	eor	r1, r1
 36a:	0b b6       	in	r0, 0x3b	; 59
 36c:	0f 92       	push	r0
 36e:	2f 93       	push	r18
 370:	3f 93       	push	r19
 372:	4f 93       	push	r20
 374:	5f 93       	push	r21
 376:	6f 93       	push	r22
 378:	7f 93       	push	r23
 37a:	8f 93       	push	r24
 37c:	9f 93       	push	r25
 37e:	af 93       	push	r26
 380:	bf 93       	push	r27
 382:	ef 93       	push	r30
 384:	ff 93       	push	r31
	//Disable interrupt - will be enable again on timer0 overflow.
	cbi(EIMSK, IRQ_PIN);
 386:	ec 98       	cbi	0x1d, 4	; 29
	touchDriver.Read();
 388:	84 e1       	ldi	r24, 0x14	; 20
 38a:	92 e0       	ldi	r25, 0x02	; 2
 38c:	f8 d2       	rcall	.+1520   	; 0x97e <_ZN11TouchDriver4ReadEv>
	SendInteger(touchDriver.getX());
 38e:	84 e1       	ldi	r24, 0x14	; 20
 390:	92 e0       	ldi	r25, 0x02	; 2
 392:	42 d2       	rcall	.+1156   	; 0x818 <_ZN11TouchDriver4getXEv>
 394:	23 df       	rcall	.-442    	; 0x1dc <_Z11SendIntegeri>
	SendChar(' ');
 396:	80 e2       	ldi	r24, 0x20	; 32
 398:	0b df       	rcall	.-490    	; 0x1b0 <_Z8SendCharc>
	SendInteger(touchDriver.getY());
 39a:	84 e1       	ldi	r24, 0x14	; 20
 39c:	92 e0       	ldi	r25, 0x02	; 2
 39e:	4a d2       	rcall	.+1172   	; 0x834 <_ZN11TouchDriver4getYEv>
 3a0:	1d df       	rcall	.-454    	; 0x1dc <_Z11SendIntegeri>
 3a2:	84 e1       	ldi	r24, 0x14	; 20
	touchDriver.SetTimer1_EnableInterrupt();
 3a4:	92 e0       	ldi	r25, 0x02	; 2
 3a6:	87 d2       	rcall	.+1294   	; 0x8b6 <_ZN11TouchDriver25SetTimer1_EnableInterruptEv>
 3a8:	ff 91       	pop	r31
 3aa:	ef 91       	pop	r30
}
 3ac:	bf 91       	pop	r27
 3ae:	af 91       	pop	r26
 3b0:	9f 91       	pop	r25
 3b2:	8f 91       	pop	r24
 3b4:	7f 91       	pop	r23
 3b6:	6f 91       	pop	r22
 3b8:	5f 91       	pop	r21
 3ba:	4f 91       	pop	r20
 3bc:	3f 91       	pop	r19
 3be:	2f 91       	pop	r18
 3c0:	0f 90       	pop	r0
 3c2:	0b be       	out	0x3b, r0	; 59
 3c4:	0f 90       	pop	r0
 3c6:	0f be       	out	0x3f, r0	; 63
 3c8:	0f 90       	pop	r0
 3ca:	1f 90       	pop	r1
 3cc:	18 95       	reti

000003ce <__vector_17>:
 3ce:	1f 92       	push	r1
 3d0:	0f 92       	push	r0

ISR(TIMER1_COMPA_vect)
{
 3d2:	0f b6       	in	r0, 0x3f	; 63
 3d4:	0f 92       	push	r0
 3d6:	11 24       	eor	r1, r1
 3d8:	0b b6       	in	r0, 0x3b	; 59
 3da:	0f 92       	push	r0
 3dc:	2f 93       	push	r18
 3de:	3f 93       	push	r19
 3e0:	4f 93       	push	r20
 3e2:	5f 93       	push	r21
 3e4:	6f 93       	push	r22
 3e6:	7f 93       	push	r23
 3e8:	8f 93       	push	r24
 3ea:	9f 93       	push	r25
 3ec:	af 93       	push	r26
 3ee:	bf 93       	push	r27
 3f0:	ef 93       	push	r30
 3f2:	ff 93       	push	r31
	TIMSK1 = 0; //Disable timer interrupt
 3f4:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x70006f>
	
	//Disable timer
	TCCR1A = 0;
 3f8:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = 0;
 3fc:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	
	sbi(EIFR, 4); //Clear INT4 flag if set in mean time to avoid additional interrupts
 400:	e4 9a       	sbi	0x1c, 4	; 28
	sbi(EIMSK, IRQ_PIN); //re-enable interrupt
 402:	ec 9a       	sbi	0x1d, 4	; 29
	SendString("Timer interrupt");
 404:	84 e0       	ldi	r24, 0x04	; 4
 406:	92 e0       	ldi	r25, 0x02	; 2
 408:	db de       	rcall	.-586    	; 0x1c0 <_Z10SendStringPc>
 40a:	ff 91       	pop	r31
 40c:	ef 91       	pop	r30
 40e:	bf 91       	pop	r27
 410:	af 91       	pop	r26
 412:	9f 91       	pop	r25
 414:	8f 91       	pop	r24
 416:	7f 91       	pop	r23
 418:	6f 91       	pop	r22
 41a:	5f 91       	pop	r21
 41c:	4f 91       	pop	r20
 41e:	3f 91       	pop	r19
 420:	2f 91       	pop	r18
 422:	0f 90       	pop	r0
 424:	0b be       	out	0x3b, r0	; 59
 426:	0f 90       	pop	r0
 428:	0f be       	out	0x3f, r0	; 63
 42a:	0f 90       	pop	r0
 42c:	1f 90       	pop	r1
 42e:	18 95       	reti

00000430 <_GLOBAL__sub_I__Z8InitUARTmhc>:
 430:	ef 92       	push	r14
 432:	ff 92       	push	r15
 434:	0f 93       	push	r16
 436:	1f 93       	push	r17
#include "TFT/Color.h"
#include "Game/GameController.h"

#include <util/delay.h>

TouchDriver touchDriver(400, 400, 4095, 320, 240);
 438:	0f 2e       	mov	r0, r31
 43a:	f0 ef       	ldi	r31, 0xF0	; 240
 43c:	ef 2e       	mov	r14, r31
 43e:	f1 2c       	mov	r15, r1
 440:	f0 2d       	mov	r31, r0
 442:	00 e4       	ldi	r16, 0x40	; 64
 444:	11 e0       	ldi	r17, 0x01	; 1
 446:	2f ef       	ldi	r18, 0xFF	; 255
 448:	3f e0       	ldi	r19, 0x0F	; 15
 44a:	40 e9       	ldi	r20, 0x90	; 144
 44c:	51 e0       	ldi	r21, 0x01	; 1
 44e:	60 e9       	ldi	r22, 0x90	; 144
 450:	71 e0       	ldi	r23, 0x01	; 1
 452:	84 e1       	ldi	r24, 0x14	; 20
 454:	92 e0       	ldi	r25, 0x02	; 2
 456:	b7 d1       	rcall	.+878    	; 0x7c6 <_ZN11TouchDriverC1Eiiiii>
	TCCR1B = 0;
	
	sbi(EIFR, 4); //Clear INT4 flag if set in mean time to avoid additional interrupts
	sbi(EIMSK, IRQ_PIN); //re-enable interrupt
	SendString("Timer interrupt");
 458:	1f 91       	pop	r17
 45a:	0f 91       	pop	r16
 45c:	ff 90       	pop	r15
 45e:	ef 90       	pop	r14
 460:	08 95       	ret

00000462 <_ZN9TFTDriver12WriteCommandEj>:
			WriteData(*(data + (r*c)+c));
		}
	}
	//Dummy command
	DisplayInversionOff();
}
 462:	5f 98       	cbi	0x0b, 7	; 11
 464:	68 b9       	out	0x08, r22	; 8
 466:	a2 98       	cbi	0x14, 2	; 20
 468:	00 00       	nop
 46a:	a2 9a       	sbi	0x14, 2	; 20
 46c:	00 00       	nop
 46e:	08 95       	ret

00000470 <_ZN9TFTDriver9WriteDataEj>:
 470:	5f 9a       	sbi	0x0b, 7	; 11
 472:	72 b9       	out	0x02, r23	; 2
 474:	68 b9       	out	0x08, r22	; 8
 476:	a2 98       	cbi	0x14, 2	; 20
 478:	00 00       	nop
 47a:	a2 9a       	sbi	0x14, 2	; 20
 47c:	00 00       	nop
 47e:	08 95       	ret

00000480 <_ZN9TFTDriverC1Eii>:
 480:	fc 01       	movw	r30, r24
 482:	73 83       	std	Z+3, r23	; 0x03
 484:	62 83       	std	Z+2, r22	; 0x02
 486:	51 83       	std	Z+1, r21	; 0x01
 488:	40 83       	st	Z, r20
 48a:	08 95       	ret

0000048c <_ZN9TFTDriver9DisplayOnEv>:
 48c:	69 e2       	ldi	r22, 0x29	; 41
 48e:	70 e0       	ldi	r23, 0x00	; 0
 490:	e8 cf       	rjmp	.-48     	; 0x462 <_ZN9TFTDriver12WriteCommandEj>
 492:	08 95       	ret

00000494 <_ZN9TFTDriver8SleepOutEv>:
 494:	61 e1       	ldi	r22, 0x11	; 17
 496:	70 e0       	ldi	r23, 0x00	; 0
 498:	e4 df       	rcall	.-56     	; 0x462 <_ZN9TFTDriver12WriteCommandEj>
 49a:	8f e3       	ldi	r24, 0x3F	; 63
 49c:	9c e9       	ldi	r25, 0x9C	; 156
 49e:	01 97       	sbiw	r24, 0x01	; 1
 4a0:	f1 f7       	brne	.-4      	; 0x49e <_ZN9TFTDriver8SleepOutEv+0xa>
 4a2:	00 c0       	rjmp	.+0      	; 0x4a4 <_ZN9TFTDriver8SleepOutEv+0x10>
 4a4:	00 00       	nop
 4a6:	08 95       	ret

000004a8 <_ZN9TFTDriver5ResetEv>:
 4a8:	24 b3       	in	r18, 0x14	; 20
 4aa:	44 b3       	in	r20, 0x14	; 20
 4ac:	81 e0       	ldi	r24, 0x01	; 1
 4ae:	90 e0       	ldi	r25, 0x00	; 0
 4b0:	bc 01       	movw	r22, r24
 4b2:	02 c0       	rjmp	.+4      	; 0x4b8 <_ZN9TFTDriver5ResetEv+0x10>
 4b4:	66 0f       	add	r22, r22
 4b6:	77 1f       	adc	r23, r23
 4b8:	2a 95       	dec	r18
 4ba:	e2 f7       	brpl	.-8      	; 0x4b4 <_ZN9TFTDriver5ResetEv+0xc>
 4bc:	9b 01       	movw	r18, r22
 4be:	20 95       	com	r18
 4c0:	30 95       	com	r19
 4c2:	24 23       	and	r18, r20
 4c4:	24 bb       	out	0x14, r18	; 20
 4c6:	7f ef       	ldi	r23, 0xFF	; 255
 4c8:	29 e6       	ldi	r18, 0x69	; 105
 4ca:	38 e1       	ldi	r19, 0x18	; 24
 4cc:	71 50       	subi	r23, 0x01	; 1
 4ce:	20 40       	sbci	r18, 0x00	; 0
 4d0:	30 40       	sbci	r19, 0x00	; 0
 4d2:	e1 f7       	brne	.-8      	; 0x4cc <_ZN9TFTDriver5ResetEv+0x24>
 4d4:	00 c0       	rjmp	.+0      	; 0x4d6 <_ZN9TFTDriver5ResetEv+0x2e>
 4d6:	00 00       	nop
 4d8:	34 b3       	in	r19, 0x14	; 20
 4da:	24 b3       	in	r18, 0x14	; 20
 4dc:	02 c0       	rjmp	.+4      	; 0x4e2 <_ZN9TFTDriver5ResetEv+0x3a>
 4de:	88 0f       	add	r24, r24
 4e0:	99 1f       	adc	r25, r25
 4e2:	3a 95       	dec	r19
 4e4:	e2 f7       	brpl	.-8      	; 0x4de <_ZN9TFTDriver5ResetEv+0x36>
 4e6:	82 2b       	or	r24, r18
 4e8:	84 bb       	out	0x14, r24	; 20
 4ea:	4f ef       	ldi	r20, 0xFF	; 255
 4ec:	68 e5       	ldi	r22, 0x58	; 88
 4ee:	76 e0       	ldi	r23, 0x06	; 6
 4f0:	41 50       	subi	r20, 0x01	; 1
 4f2:	60 40       	sbci	r22, 0x00	; 0
 4f4:	70 40       	sbci	r23, 0x00	; 0
 4f6:	e1 f7       	brne	.-8      	; 0x4f0 <_ZN9TFTDriver5ResetEv+0x48>
 4f8:	00 c0       	rjmp	.+0      	; 0x4fa <_ZN9TFTDriver5ResetEv+0x52>
 4fa:	00 00       	nop
 4fc:	08 95       	ret

000004fe <_ZN9TFTDriver19MemoryAccessControlEh>:
 4fe:	0f 93       	push	r16
 500:	1f 93       	push	r17
 502:	cf 93       	push	r28
 504:	8c 01       	movw	r16, r24
 506:	c6 2f       	mov	r28, r22
 508:	66 e3       	ldi	r22, 0x36	; 54
 50a:	70 e0       	ldi	r23, 0x00	; 0
 50c:	aa df       	rcall	.-172    	; 0x462 <_ZN9TFTDriver12WriteCommandEj>
 50e:	6c 2f       	mov	r22, r28
 510:	70 e0       	ldi	r23, 0x00	; 0
 512:	c8 01       	movw	r24, r16
 514:	ad df       	rcall	.-166    	; 0x470 <_ZN9TFTDriver9WriteDataEj>
 516:	cf 91       	pop	r28
 518:	1f 91       	pop	r17
 51a:	0f 91       	pop	r16
 51c:	08 95       	ret

0000051e <_ZN9TFTDriver20InterfacePixelFormatEh>:
 51e:	0f 93       	push	r16
 520:	1f 93       	push	r17
 522:	cf 93       	push	r28
 524:	8c 01       	movw	r16, r24
 526:	c6 2f       	mov	r28, r22
 528:	6a e3       	ldi	r22, 0x3A	; 58
 52a:	70 e0       	ldi	r23, 0x00	; 0
 52c:	9a df       	rcall	.-204    	; 0x462 <_ZN9TFTDriver12WriteCommandEj>
 52e:	6c 2f       	mov	r22, r28
 530:	70 e0       	ldi	r23, 0x00	; 0
 532:	c8 01       	movw	r24, r16
 534:	9d df       	rcall	.-198    	; 0x470 <_ZN9TFTDriver9WriteDataEj>
 536:	cf 91       	pop	r28
 538:	1f 91       	pop	r17
 53a:	0f 91       	pop	r16
 53c:	08 95       	ret

0000053e <_ZN9TFTDriver11DisplayInitEv>:
 53e:	cf 93       	push	r28
 540:	df 93       	push	r29
 542:	ec 01       	movw	r28, r24
 544:	57 9a       	sbi	0x0a, 7	; 10
 546:	8f ef       	ldi	r24, 0xFF	; 255
 548:	81 b9       	out	0x01, r24	; 1
 54a:	87 b9       	out	0x07, r24	; 7
 54c:	9a 9a       	sbi	0x13, 2	; 19
 54e:	99 9a       	sbi	0x13, 1	; 19
 550:	98 9a       	sbi	0x13, 0	; 19
 552:	5f 9a       	sbi	0x0b, 7	; 11
 554:	a2 9a       	sbi	0x14, 2	; 20
 556:	a1 98       	cbi	0x14, 1	; 20
 558:	a0 9a       	sbi	0x14, 0	; 20
 55a:	ce 01       	movw	r24, r28
 55c:	a5 df       	rcall	.-182    	; 0x4a8 <_ZN9TFTDriver5ResetEv>
 55e:	ce 01       	movw	r24, r28
 560:	99 df       	rcall	.-206    	; 0x494 <_ZN9TFTDriver8SleepOutEv>
 562:	ce 01       	movw	r24, r28
 564:	93 df       	rcall	.-218    	; 0x48c <_ZN9TFTDriver9DisplayOnEv>
 566:	8f e1       	ldi	r24, 0x1F	; 31
 568:	9e e4       	ldi	r25, 0x4E	; 78
 56a:	01 97       	sbiw	r24, 0x01	; 1
 56c:	f1 f7       	brne	.-4      	; 0x56a <_ZN9TFTDriver11DisplayInitEv+0x2c>
 56e:	00 c0       	rjmp	.+0      	; 0x570 <_ZN9TFTDriver11DisplayInitEv+0x32>
 570:	00 00       	nop
 572:	68 e0       	ldi	r22, 0x08	; 8
 574:	ce 01       	movw	r24, r28
 576:	c3 df       	rcall	.-122    	; 0x4fe <_ZN9TFTDriver19MemoryAccessControlEh>
 578:	65 e0       	ldi	r22, 0x05	; 5
 57a:	ce 01       	movw	r24, r28
 57c:	d0 df       	rcall	.-96     	; 0x51e <_ZN9TFTDriver20InterfacePixelFormatEh>
 57e:	df 91       	pop	r29
 580:	cf 91       	pop	r28
 582:	08 95       	ret

00000584 <_ZN9TFTDriver11MemoryWriteEv>:
 584:	6c e2       	ldi	r22, 0x2C	; 44
 586:	70 e0       	ldi	r23, 0x00	; 0
 588:	6c cf       	rjmp	.-296    	; 0x462 <_ZN9TFTDriver12WriteCommandEj>
 58a:	08 95       	ret

0000058c <_ZN9TFTDriver16SetColumnAddressEjj>:
 58c:	ef 92       	push	r14
 58e:	ff 92       	push	r15
 590:	0f 93       	push	r16
 592:	1f 93       	push	r17
 594:	cf 93       	push	r28
 596:	df 93       	push	r29
 598:	ec 01       	movw	r28, r24
 59a:	e6 2e       	mov	r14, r22
 59c:	07 2f       	mov	r16, r23
 59e:	f4 2e       	mov	r15, r20
 5a0:	15 2f       	mov	r17, r21
 5a2:	6a e2       	ldi	r22, 0x2A	; 42
 5a4:	70 e0       	ldi	r23, 0x00	; 0
 5a6:	5d df       	rcall	.-326    	; 0x462 <_ZN9TFTDriver12WriteCommandEj>
 5a8:	60 2f       	mov	r22, r16
 5aa:	70 e0       	ldi	r23, 0x00	; 0
 5ac:	ce 01       	movw	r24, r28
 5ae:	60 df       	rcall	.-320    	; 0x470 <_ZN9TFTDriver9WriteDataEj>
 5b0:	6e 2d       	mov	r22, r14
 5b2:	70 2f       	mov	r23, r16
 5b4:	ce 01       	movw	r24, r28
 5b6:	5c df       	rcall	.-328    	; 0x470 <_ZN9TFTDriver9WriteDataEj>
 5b8:	61 2f       	mov	r22, r17
 5ba:	70 e0       	ldi	r23, 0x00	; 0
 5bc:	ce 01       	movw	r24, r28
 5be:	58 df       	rcall	.-336    	; 0x470 <_ZN9TFTDriver9WriteDataEj>
 5c0:	6f 2d       	mov	r22, r15
 5c2:	71 2f       	mov	r23, r17
 5c4:	ce 01       	movw	r24, r28
 5c6:	54 df       	rcall	.-344    	; 0x470 <_ZN9TFTDriver9WriteDataEj>
 5c8:	df 91       	pop	r29
 5ca:	cf 91       	pop	r28
 5cc:	1f 91       	pop	r17
 5ce:	0f 91       	pop	r16
 5d0:	ff 90       	pop	r15
 5d2:	ef 90       	pop	r14
 5d4:	08 95       	ret

000005d6 <_ZN9TFTDriver14SetPageAddressEjj>:
 5d6:	ef 92       	push	r14
 5d8:	ff 92       	push	r15
 5da:	0f 93       	push	r16
 5dc:	1f 93       	push	r17
 5de:	cf 93       	push	r28
 5e0:	df 93       	push	r29
 5e2:	ec 01       	movw	r28, r24
 5e4:	e6 2e       	mov	r14, r22
 5e6:	07 2f       	mov	r16, r23
 5e8:	f4 2e       	mov	r15, r20
 5ea:	15 2f       	mov	r17, r21
 5ec:	6b e2       	ldi	r22, 0x2B	; 43
 5ee:	70 e0       	ldi	r23, 0x00	; 0
 5f0:	38 df       	rcall	.-400    	; 0x462 <_ZN9TFTDriver12WriteCommandEj>
 5f2:	60 2f       	mov	r22, r16
 5f4:	70 e0       	ldi	r23, 0x00	; 0
 5f6:	ce 01       	movw	r24, r28
 5f8:	3b df       	rcall	.-394    	; 0x470 <_ZN9TFTDriver9WriteDataEj>
 5fa:	6e 2d       	mov	r22, r14
 5fc:	70 2f       	mov	r23, r16
 5fe:	ce 01       	movw	r24, r28
 600:	37 df       	rcall	.-402    	; 0x470 <_ZN9TFTDriver9WriteDataEj>
 602:	61 2f       	mov	r22, r17
 604:	70 e0       	ldi	r23, 0x00	; 0
 606:	ce 01       	movw	r24, r28
 608:	33 df       	rcall	.-410    	; 0x470 <_ZN9TFTDriver9WriteDataEj>
 60a:	6f 2d       	mov	r22, r15
 60c:	71 2f       	mov	r23, r17
 60e:	ce 01       	movw	r24, r28
 610:	2f df       	rcall	.-418    	; 0x470 <_ZN9TFTDriver9WriteDataEj>
 612:	df 91       	pop	r29
 614:	cf 91       	pop	r28
 616:	1f 91       	pop	r17
 618:	0f 91       	pop	r16
 61a:	ff 90       	pop	r15
 61c:	ef 90       	pop	r14
 61e:	08 95       	ret

00000620 <_ZN9TFTDriver19DisplayInversionOffEv>:
 620:	60 e2       	ldi	r22, 0x20	; 32
 622:	70 e0       	ldi	r23, 0x00	; 0
 624:	1e cf       	rjmp	.-452    	; 0x462 <_ZN9TFTDriver12WriteCommandEj>
 626:	08 95       	ret

00000628 <_ZN9TFTDriver8DrawGameEPP8UIObjectiS1_>:

void TFTDriver::DrawGame(UIObject ** pillars, int numPillars, UIObject *flappy)
{
 628:	2f 92       	push	r2
 62a:	3f 92       	push	r3
 62c:	4f 92       	push	r4
 62e:	5f 92       	push	r5
 630:	6f 92       	push	r6
 632:	7f 92       	push	r7
 634:	8f 92       	push	r8
 636:	9f 92       	push	r9
 638:	af 92       	push	r10
 63a:	bf 92       	push	r11
 63c:	cf 92       	push	r12
 63e:	df 92       	push	r13
 640:	ef 92       	push	r14
 642:	ff 92       	push	r15
 644:	0f 93       	push	r16
 646:	1f 93       	push	r17
 648:	cf 93       	push	r28
 64a:	df 93       	push	r29
	for(int i = 0; i < numPillars; i++)
 64c:	14 16       	cp	r1, r20
 64e:	15 06       	cpc	r1, r21
 650:	0c f0       	brlt	.+2      	; 0x654 <_ZN9TFTDriver8DrawGameEPP8UIObjectiS1_+0x2c>
 652:	5a c0       	rjmp	.+180    	; 0x708 <_ZN9TFTDriver8DrawGameEPP8UIObjectiS1_+0xe0>
 654:	1b 01       	movw	r2, r22
 656:	ec 01       	movw	r28, r24
 658:	7b 01       	movw	r14, r22
 65a:	44 0f       	add	r20, r20
 65c:	55 1f       	adc	r21, r21
 65e:	24 0e       	add	r2, r20
 660:	35 1e       	adc	r3, r21
 662:	87 01       	movw	r16, r14
	{
		int startX = pillars[i]->GetStartX();
 664:	f7 01       	movw	r30, r14
 666:	80 81       	ld	r24, Z
 668:	91 81       	ldd	r25, Z+1	; 0x01
 66a:	db d1       	rcall	.+950    	; 0xa22 <_ZN8UIObject9GetStartXEv>
 66c:	4c 01       	movw	r8, r24
		int width = pillars[i]->GetWidth();
 66e:	f7 01       	movw	r30, r14
 670:	80 81       	ld	r24, Z
 672:	91 81       	ldd	r25, Z+1	; 0x01
 674:	de d1       	rcall	.+956    	; 0xa32 <_ZN8UIObject8GetWidthEv>
 676:	5c 01       	movw	r10, r24
		int startY = pillars[i]->GetStartY();
 678:	f7 01       	movw	r30, r14
 67a:	80 81       	ld	r24, Z
 67c:	91 81       	ldd	r25, Z+1	; 0x01
 67e:	d5 d1       	rcall	.+938    	; 0xa2a <_ZN8UIObject9GetStartYEv>
 680:	3c 01       	movw	r6, r24
		int height = pillars[i]->GetHeight();
 682:	f7 01       	movw	r30, r14
 684:	81 91       	ld	r24, Z+
 686:	91 91       	ld	r25, Z+
 688:	7f 01       	movw	r14, r30
 68a:	c7 d1       	rcall	.+910    	; 0xa1a <_ZN8UIObject9GetHeightEv>
 68c:	6c 01       	movw	r12, r24
		unsigned int color = pillars[i]->GetColor();
 68e:	f8 01       	movw	r30, r16
 690:	80 81       	ld	r24, Z
 692:	91 81       	ldd	r25, Z+1	; 0x01
 694:	d2 d1       	rcall	.+932    	; 0xa3a <_ZN8UIObject8GetColorEv>
 696:	8c 01       	movw	r16, r24
 698:	a4 01       	movw	r20, r8
		
		SetPageAddress(startX, (startX + width) - 1); //Maybe add error checking
 69a:	4a 0d       	add	r20, r10
 69c:	5b 1d       	adc	r21, r11
 69e:	41 50       	subi	r20, 0x01	; 1
 6a0:	51 09       	sbc	r21, r1
 6a2:	b4 01       	movw	r22, r8
 6a4:	ce 01       	movw	r24, r28
 6a6:	97 df       	rcall	.-210    	; 0x5d6 <_ZN9TFTDriver14SetPageAddressEjj>
 6a8:	a3 01       	movw	r20, r6
		SetColumnAddress(startY, (startY + height) - 1);
 6aa:	4c 0d       	add	r20, r12
 6ac:	5d 1d       	adc	r21, r13
 6ae:	41 50       	subi	r20, 0x01	; 1
 6b0:	51 09       	sbc	r21, r1
 6b2:	b3 01       	movw	r22, r6
 6b4:	ce 01       	movw	r24, r28
 6b6:	6a df       	rcall	.-300    	; 0x58c <_ZN9TFTDriver16SetColumnAddressEjj>
		MemoryWrite();
 6b8:	ce 01       	movw	r24, r28
 6ba:	64 df       	rcall	.-312    	; 0x584 <_ZN9TFTDriver11MemoryWriteEv>
 6bc:	ac 9c       	mul	r10, r12
		
		long int numPixels = (long int)(width * height);
 6be:	40 01       	movw	r8, r0
 6c0:	ad 9c       	mul	r10, r13
 6c2:	90 0c       	add	r9, r0
 6c4:	bc 9c       	mul	r11, r12
 6c6:	90 0c       	add	r9, r0
 6c8:	11 24       	eor	r1, r1
 6ca:	09 2c       	mov	r0, r9
 6cc:	00 0c       	add	r0, r0
 6ce:	aa 08       	sbc	r10, r10
 6d0:	bb 08       	sbc	r11, r11
 6d2:	18 14       	cp	r1, r8
		for(long int p = 0; p < numPixels; p++)
 6d4:	19 04       	cpc	r1, r9
 6d6:	1a 04       	cpc	r1, r10
 6d8:	1b 04       	cpc	r1, r11
 6da:	84 f4       	brge	.+32     	; 0x6fc <_ZN9TFTDriver8DrawGameEPP8UIObjectiS1_+0xd4>
 6dc:	41 2c       	mov	r4, r1
 6de:	51 2c       	mov	r5, r1
 6e0:	32 01       	movw	r6, r4
}

// Red 0-31, Green 0-63, Blue 0-31
void TFTDriver::WritePixel(int encodedColor)
{
	WriteData(encodedColor);
 6e2:	b8 01       	movw	r22, r16
 6e4:	ce 01       	movw	r24, r28
 6e6:	c4 de       	rcall	.-632    	; 0x470 <_ZN9TFTDriver9WriteDataEj>
 6e8:	ff ef       	ldi	r31, 0xFF	; 255
		SetPageAddress(startX, (startX + width) - 1); //Maybe add error checking
		SetColumnAddress(startY, (startY + height) - 1);
		MemoryWrite();
		
		long int numPixels = (long int)(width * height);
		for(long int p = 0; p < numPixels; p++)
 6ea:	4f 1a       	sub	r4, r31
 6ec:	5f 0a       	sbc	r5, r31
 6ee:	6f 0a       	sbc	r6, r31
 6f0:	7f 0a       	sbc	r7, r31
 6f2:	48 14       	cp	r4, r8
 6f4:	59 04       	cpc	r5, r9
 6f6:	6a 04       	cpc	r6, r10
 6f8:	7b 04       	cpc	r7, r11
 6fa:	9c f3       	brlt	.-26     	; 0x6e2 <_ZN9TFTDriver8DrawGameEPP8UIObjectiS1_+0xba>
		{
			WritePixel(color);	
		}
		//Dummy command
		DisplayInversionOff();
 6fc:	ce 01       	movw	r24, r28
 6fe:	90 df       	rcall	.-224    	; 0x620 <_ZN9TFTDriver19DisplayInversionOffEv>
 700:	e2 14       	cp	r14, r2
	DisplayInversionOff();
}

void TFTDriver::DrawGame(UIObject ** pillars, int numPillars, UIObject *flappy)
{
	for(int i = 0; i < numPillars; i++)
 702:	f3 04       	cpc	r15, r3
 704:	09 f0       	breq	.+2      	; 0x708 <_ZN9TFTDriver8DrawGameEPP8UIObjectiS1_+0xe0>
 706:	ad cf       	rjmp	.-166    	; 0x662 <_ZN9TFTDriver8DrawGameEPP8UIObjectiS1_+0x3a>
 708:	df 91       	pop	r29
		}
		//Dummy command
		DisplayInversionOff();
	}
	//Draw flappy
}
 70a:	cf 91       	pop	r28
 70c:	1f 91       	pop	r17
 70e:	0f 91       	pop	r16
 710:	ff 90       	pop	r15
 712:	ef 90       	pop	r14
 714:	df 90       	pop	r13
 716:	cf 90       	pop	r12
 718:	bf 90       	pop	r11
 71a:	af 90       	pop	r10
 71c:	9f 90       	pop	r9
 71e:	8f 90       	pop	r8
 720:	7f 90       	pop	r7
 722:	6f 90       	pop	r6
 724:	5f 90       	pop	r5
 726:	4f 90       	pop	r4
 728:	3f 90       	pop	r3
 72a:	2f 90       	pop	r2
 72c:	08 95       	ret

0000072e <_ZN9TFTDriver14DrawBackgroundEP5Color>:
 72e:	8f 92       	push	r8

void TFTDriver::DrawBackground(Color *color)
{
 730:	9f 92       	push	r9
 732:	af 92       	push	r10
 734:	bf 92       	push	r11
 736:	cf 92       	push	r12
 738:	df 92       	push	r13
 73a:	ef 92       	push	r14
 73c:	ff 92       	push	r15
 73e:	0f 93       	push	r16
 740:	1f 93       	push	r17
 742:	cf 93       	push	r28
 744:	df 93       	push	r29
 746:	ec 01       	movw	r28, r24
	}
	char getRed() { return _red; }
	char getGreen() { return _green; }
	char getBlue() { return _blue; }
	char* getName() { return _name; }
	unsigned int getEncodedColor() { return _encodedColor; }	
 748:	fb 01       	movw	r30, r22
 74a:	05 81       	ldd	r16, Z+5	; 0x05
 74c:	16 81       	ldd	r17, Z+6	; 0x06
	int encodedColor = color->getEncodedColor();
	SetPageAddress(0, _width - 1);
 74e:	4a 81       	ldd	r20, Y+2	; 0x02
 750:	5b 81       	ldd	r21, Y+3	; 0x03
 752:	41 50       	subi	r20, 0x01	; 1
 754:	51 09       	sbc	r21, r1
 756:	60 e0       	ldi	r22, 0x00	; 0
 758:	70 e0       	ldi	r23, 0x00	; 0
 75a:	3d df       	rcall	.-390    	; 0x5d6 <_ZN9TFTDriver14SetPageAddressEjj>
	SetColumnAddress(0, _height - 1);
 75c:	48 81       	ld	r20, Y
 75e:	59 81       	ldd	r21, Y+1	; 0x01
 760:	41 50       	subi	r20, 0x01	; 1
 762:	51 09       	sbc	r21, r1
 764:	60 e0       	ldi	r22, 0x00	; 0
 766:	70 e0       	ldi	r23, 0x00	; 0
 768:	ce 01       	movw	r24, r28
 76a:	10 df       	rcall	.-480    	; 0x58c <_ZN9TFTDriver16SetColumnAddressEjj>
	MemoryWrite();
 76c:	ce 01       	movw	r24, r28
 76e:	0a df       	rcall	.-492    	; 0x584 <_ZN9TFTDriver11MemoryWriteEv>
 770:	2a 81       	ldd	r18, Y+2	; 0x02
	long int numPixels = (long int)_width * _height;
 772:	3b 81       	ldd	r19, Y+3	; 0x03
 774:	a8 81       	ld	r26, Y
 776:	b9 81       	ldd	r27, Y+1	; 0x01
 778:	79 d1       	rcall	.+754    	; 0xa6c <__mulhisi3>
 77a:	4b 01       	movw	r8, r22
 77c:	5c 01       	movw	r10, r24
 77e:	16 16       	cp	r1, r22
	for(long int i = 0; i < numPixels; ++i)
 780:	17 06       	cpc	r1, r23
 782:	18 06       	cpc	r1, r24
 784:	19 06       	cpc	r1, r25
 786:	84 f4       	brge	.+32     	; 0x7a8 <_ZN9TFTDriver14DrawBackgroundEP5Color+0x7a>
 788:	c1 2c       	mov	r12, r1
 78a:	d1 2c       	mov	r13, r1
 78c:	76 01       	movw	r14, r12
}

// Red 0-31, Green 0-63, Blue 0-31
void TFTDriver::WritePixel(int encodedColor)
{
	WriteData(encodedColor);
 78e:	b8 01       	movw	r22, r16
 790:	ce 01       	movw	r24, r28
 792:	6e de       	rcall	.-804    	; 0x470 <_ZN9TFTDriver9WriteDataEj>
 794:	ff ef       	ldi	r31, 0xFF	; 255
	int encodedColor = color->getEncodedColor();
	SetPageAddress(0, _width - 1);
	SetColumnAddress(0, _height - 1);
	MemoryWrite();
	long int numPixels = (long int)_width * _height;
	for(long int i = 0; i < numPixels; ++i)
 796:	cf 1a       	sub	r12, r31
 798:	df 0a       	sbc	r13, r31
 79a:	ef 0a       	sbc	r14, r31
 79c:	ff 0a       	sbc	r15, r31
 79e:	8c 14       	cp	r8, r12
 7a0:	9d 04       	cpc	r9, r13
 7a2:	ae 04       	cpc	r10, r14
 7a4:	bf 04       	cpc	r11, r15
 7a6:	99 f7       	brne	.-26     	; 0x78e <_ZN9TFTDriver14DrawBackgroundEP5Color+0x60>
	{
		WritePixel(encodedColor);
	}
	//Dummy command
	DisplayInversionOff();
 7a8:	ce 01       	movw	r24, r28
 7aa:	3a df       	rcall	.-396    	; 0x620 <_ZN9TFTDriver19DisplayInversionOffEv>
 7ac:	df 91       	pop	r29
}
 7ae:	cf 91       	pop	r28
 7b0:	1f 91       	pop	r17
 7b2:	0f 91       	pop	r16
 7b4:	ff 90       	pop	r15
 7b6:	ef 90       	pop	r14
 7b8:	df 90       	pop	r13
 7ba:	cf 90       	pop	r12
 7bc:	bf 90       	pop	r11
 7be:	af 90       	pop	r10
 7c0:	9f 90       	pop	r9
 7c2:	8f 90       	pop	r8
 7c4:	08 95       	ret

000007c6 <_ZN11TouchDriverC1Eiiiii>:
 7c6:	ef 92       	push	r14
	bool dataAvailable;
	//cbi(IRQ_DDR, IRQ_PIN);
	dataAvailable = !rbi(IRQ_PORT,IRQ_PIN);
	//sbi(IRQ_DDR, IRQ_PIN);
	return dataAvailable;
}
 7c8:	ff 92       	push	r15
 7ca:	0f 93       	push	r16
 7cc:	1f 93       	push	r17
 7ce:	cf 93       	push	r28
 7d0:	df 93       	push	r29
 7d2:	fc 01       	movw	r30, r24
 7d4:	ea 01       	movw	r28, r20
 7d6:	75 83       	std	Z+5, r23	; 0x05
 7d8:	64 83       	std	Z+4, r22	; 0x04
 7da:	57 83       	std	Z+7, r21	; 0x07
 7dc:	46 83       	std	Z+6, r20	; 0x06
 7de:	11 86       	std	Z+9, r1	; 0x09
 7e0:	10 86       	std	Z+8, r1	; 0x08
 7e2:	15 87       	std	Z+13, r17	; 0x0d
 7e4:	04 87       	std	Z+12, r16	; 0x0c
 7e6:	f7 86       	std	Z+15, r15	; 0x0f
 7e8:	e6 86       	std	Z+14, r14	; 0x0e
 7ea:	33 87       	std	Z+11, r19	; 0x0b
 7ec:	22 87       	std	Z+10, r18	; 0x0a
 7ee:	c9 01       	movw	r24, r18
 7f0:	86 1b       	sub	r24, r22
 7f2:	97 0b       	sbc	r25, r23
 7f4:	b8 01       	movw	r22, r16
 7f6:	27 d1       	rcall	.+590    	; 0xa46 <__divmodhi4>
 7f8:	71 8b       	std	Z+17, r23	; 0x11
 7fa:	60 8b       	std	Z+16, r22	; 0x10
 7fc:	c9 01       	movw	r24, r18
 7fe:	8c 1b       	sub	r24, r28
 800:	9d 0b       	sbc	r25, r29
 802:	b7 01       	movw	r22, r14
 804:	20 d1       	rcall	.+576    	; 0xa46 <__divmodhi4>
 806:	73 8b       	std	Z+19, r23	; 0x13
 808:	62 8b       	std	Z+18, r22	; 0x12
 80a:	df 91       	pop	r29
 80c:	cf 91       	pop	r28
 80e:	1f 91       	pop	r17
 810:	0f 91       	pop	r16
 812:	ff 90       	pop	r15
 814:	ef 90       	pop	r14
 816:	08 95       	ret

00000818 <_ZN11TouchDriver4getXEv>:
 818:	fc 01       	movw	r30, r24
 81a:	20 81       	ld	r18, Z
 81c:	31 81       	ldd	r19, Z+1	; 0x01
 81e:	84 81       	ldd	r24, Z+4	; 0x04
 820:	95 81       	ldd	r25, Z+5	; 0x05
 822:	a9 01       	movw	r20, r18
 824:	48 1b       	sub	r20, r24
 826:	59 0b       	sbc	r21, r25
 828:	ca 01       	movw	r24, r20
 82a:	60 89       	ldd	r22, Z+16	; 0x10
 82c:	71 89       	ldd	r23, Z+17	; 0x11
 82e:	0b d1       	rcall	.+534    	; 0xa46 <__divmodhi4>
 830:	cb 01       	movw	r24, r22
 832:	08 95       	ret

00000834 <_ZN11TouchDriver4getYEv>:
 834:	fc 01       	movw	r30, r24
 836:	22 81       	ldd	r18, Z+2	; 0x02
 838:	33 81       	ldd	r19, Z+3	; 0x03
 83a:	86 81       	ldd	r24, Z+6	; 0x06
 83c:	97 81       	ldd	r25, Z+7	; 0x07
 83e:	a9 01       	movw	r20, r18
 840:	48 1b       	sub	r20, r24
 842:	59 0b       	sbc	r21, r25
 844:	ca 01       	movw	r24, r20
 846:	62 89       	ldd	r22, Z+18	; 0x12
 848:	73 89       	ldd	r23, Z+19	; 0x13
 84a:	fd d0       	rcall	.+506    	; 0xa46 <__divmodhi4>
 84c:	cb 01       	movw	r24, r22
 84e:	08 95       	ret

00000850 <_ZN11TouchDriver10ClockPulseEv>:
}

void TouchDriver::ClockPulse()
{
	//needs to be at least 500 to achieve 1.5 micro sec pr. 3 clockpulses
	_NOP();
 850:	00 00       	nop
	_NOP();
 852:	00 00       	nop
	//_NOP();
	//_NOP();
	//_NOP();
	sbi(CLK_PORT,CLK_PIN);
 854:	e2 e0       	ldi	r30, 0x02	; 2
 856:	f1 e0       	ldi	r31, 0x01	; 1
 858:	80 81       	ld	r24, Z
 85a:	88 60       	ori	r24, 0x08	; 8
 85c:	80 83       	st	Z, r24
	_NOP();
 85e:	00 00       	nop
	_NOP();
 860:	00 00       	nop
	//_NOP();
	//_NOP();
	//_NOP();
	cbi(CLK_PORT,CLK_PIN);
 862:	80 81       	ld	r24, Z
 864:	87 7f       	andi	r24, 0xF7	; 247
 866:	80 83       	st	Z, r24
 868:	08 95       	ret

0000086a <_ZN11TouchDriver8ReadDataEv>:
	}
	cbi(DIN_PORT,DIN_PIN);
}

int16_t TouchDriver::ReadData()
{
 86a:	ef 92       	push	r14
 86c:	ff 92       	push	r15
 86e:	0f 93       	push	r16
 870:	1f 93       	push	r17
 872:	cf 93       	push	r28
 874:	df 93       	push	r29
 876:	7c 01       	movw	r14, r24
	int16_t data = 0;
	_NOP();
 878:	00 00       	nop
	_NOP();
 87a:	00 00       	nop
	_NOP();
 87c:	00 00       	nop
	ClockPulse(); //Busy clock pulse
 87e:	e8 df       	rcall	.-48     	; 0x850 <_ZN11TouchDriver10ClockPulseEv>
 880:	0c e0       	ldi	r16, 0x0C	; 12
 882:	10 e0       	ldi	r17, 0x00	; 0
	cbi(DIN_PORT,DIN_PIN);
}

int16_t TouchDriver::ReadData()
{
	int16_t data = 0;
 884:	c0 e0       	ldi	r28, 0x00	; 0
 886:	d0 e0       	ldi	r29, 0x00	; 0
	_NOP();
	_NOP();
	ClockPulse(); //Busy clock pulse
	for (int i=0; i<12;i++)
	{
		data = data<<(1);
 888:	cc 0f       	add	r28, r28
 88a:	dd 1f       	adc	r29, r29
		if(rbi(DOUT_PORT,DOUT_PIN))
 88c:	65 99       	sbic	0x0c, 5	; 12
		{
			data++;
 88e:	21 96       	adiw	r28, 0x01	; 1
		}
		ClockPulse();
 890:	c7 01       	movw	r24, r14
 892:	de df       	rcall	.-68     	; 0x850 <_ZN11TouchDriver10ClockPulseEv>
 894:	01 50       	subi	r16, 0x01	; 1
 896:	11 09       	sbc	r17, r1
	}
	for (int i=0; i<3;i++)
	{
		ClockPulse();
 898:	b9 f7       	brne	.-18     	; 0x888 <_ZN11TouchDriver8ReadDataEv+0x1e>
 89a:	c7 01       	movw	r24, r14
 89c:	d9 df       	rcall	.-78     	; 0x850 <_ZN11TouchDriver10ClockPulseEv>
 89e:	c7 01       	movw	r24, r14
 8a0:	d7 df       	rcall	.-82     	; 0x850 <_ZN11TouchDriver10ClockPulseEv>
 8a2:	c7 01       	movw	r24, r14
 8a4:	d5 df       	rcall	.-86     	; 0x850 <_ZN11TouchDriver10ClockPulseEv>
	}
	return data;
}
 8a6:	ce 01       	movw	r24, r28
 8a8:	df 91       	pop	r29
 8aa:	cf 91       	pop	r28
 8ac:	1f 91       	pop	r17
 8ae:	0f 91       	pop	r16
 8b0:	ff 90       	pop	r15
 8b2:	ef 90       	pop	r14
 8b4:	08 95       	ret

000008b6 <_ZN11TouchDriver25SetTimer1_EnableInterruptEv>:
	cbi(CLK_PORT,CLK_PIN);
}

void TouchDriver::SetTimer1_EnableInterrupt()
{
	TIMSK1 = 2; //Enable interrupt on compare A for timer 1
 8b6:	82 e0       	ldi	r24, 0x02	; 2
 8b8:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x70006f>
	TCCR1A &= 0b11111100; //Set CTC mode
 8bc:	e0 e8       	ldi	r30, 0x80	; 128
 8be:	f0 e0       	ldi	r31, 0x00	; 0
 8c0:	80 81       	ld	r24, Z
 8c2:	8c 7f       	andi	r24, 0xFC	; 252
 8c4:	80 83       	st	Z, r24
	TCCR1B &= 0b11101111; //Set CTC mode
 8c6:	e1 e8       	ldi	r30, 0x81	; 129
 8c8:	f0 e0       	ldi	r31, 0x00	; 0
 8ca:	80 81       	ld	r24, Z
 8cc:	8f 7e       	andi	r24, 0xEF	; 239
 8ce:	80 83       	st	Z, r24
	TCCR1B |= 0b00001000; //Set CTC mode
 8d0:	80 81       	ld	r24, Z
 8d2:	88 60       	ori	r24, 0x08	; 8
 8d4:	80 83       	st	Z, r24
	OCR1A = 25000; //Compare on when timer reaches 25000 - every 100 ms;
 8d6:	88 ea       	ldi	r24, 0xA8	; 168
 8d8:	91 e6       	ldi	r25, 0x61	; 97
 8da:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
 8de:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	TCCR1B |= 0b00000011; //Set 64 clock prescaler and start timer
 8e2:	80 81       	ld	r24, Z
 8e4:	83 60       	ori	r24, 0x03	; 3
 8e6:	80 83       	st	Z, r24
 8e8:	08 95       	ret

000008ea <_ZN11TouchDriver10ClearClockEv>:
}
void TouchDriver::ClearClock()
{
	cbi(CLK_PORT,CLK_PIN);
 8ea:	e2 e0       	ldi	r30, 0x02	; 2
 8ec:	f1 e0       	ldi	r31, 0x01	; 1
 8ee:	80 81       	ld	r24, Z
 8f0:	87 7f       	andi	r24, 0xF7	; 247
 8f2:	80 83       	st	Z, r24
 8f4:	08 95       	ret

000008f6 <_ZN11TouchDriver9WriteDataEh>:
	//sbi(IRQ_DDR, IRQ_PIN);
	return dataAvailable;
}

void TouchDriver::WriteData(unsigned char data)
{
 8f6:	ef 92       	push	r14
 8f8:	ff 92       	push	r15
 8fa:	1f 93       	push	r17
 8fc:	cf 93       	push	r28
 8fe:	df 93       	push	r29
 900:	7c 01       	movw	r14, r24
 902:	16 2f       	mov	r17, r22
	unsigned char temp = data;
	
	ClearClock();
 904:	f2 df       	rcall	.-28     	; 0x8ea <_ZN11TouchDriver10ClearClockEv>
 906:	c8 e0       	ldi	r28, 0x08	; 8
 908:	d0 e0       	ldi	r29, 0x00	; 0
	for(int i=0;i<8;i++)
	{
		if(temp & 0b10000000)
 90a:	11 23       	and	r17, r17
 90c:	14 f4       	brge	.+4      	; 0x912 <_ZN11TouchDriver9WriteDataEh+0x1c>
		{
			sbi(DIN_PORT,DIN_PIN);
 90e:	a5 9a       	sbi	0x14, 5	; 20
 910:	01 c0       	rjmp	.+2      	; 0x914 <_ZN11TouchDriver9WriteDataEh+0x1e>
		}
		else
		{
			cbi(DIN_PORT,DIN_PIN);	
 912:	a5 98       	cbi	0x14, 5	; 20
		}
		temp = temp <<(1);
 914:	11 0f       	add	r17, r17
		_NOP();
 916:	00 00       	nop
		ClockPulse();
 918:	c7 01       	movw	r24, r14
 91a:	9a df       	rcall	.-204    	; 0x850 <_ZN11TouchDriver10ClockPulseEv>
 91c:	21 97       	sbiw	r28, 0x01	; 1
void TouchDriver::WriteData(unsigned char data)
{
	unsigned char temp = data;
	
	ClearClock();
	for(int i=0;i<8;i++)
 91e:	a9 f7       	brne	.-22     	; 0x90a <_ZN11TouchDriver9WriteDataEh+0x14>
		}
		temp = temp <<(1);
		_NOP();
		ClockPulse();
	}
	cbi(DIN_PORT,DIN_PIN);
 920:	a5 98       	cbi	0x14, 5	; 20
}
 922:	df 91       	pop	r29
 924:	cf 91       	pop	r28
 926:	1f 91       	pop	r17
 928:	ff 90       	pop	r15
 92a:	ef 90       	pop	r14
 92c:	08 95       	ret

0000092e <_ZN11TouchDriver9InitTouchEv>:
{
	_xOffset = 0;
	_yOffset = 0;
}
void TouchDriver::InitTouch()
{
 92e:	cf 93       	push	r28
 930:	df 93       	push	r29
 932:	ec 01       	movw	r28, r24
	//P Directions
	sbi(CLK_DDR, CLK_PIN);
 934:	e1 e0       	ldi	r30, 0x01	; 1
 936:	f1 e0       	ldi	r31, 0x01	; 1
 938:	80 81       	ld	r24, Z
 93a:	88 60       	ori	r24, 0x08	; 8
 93c:	80 83       	st	Z, r24
	sbi(DIN_DDR, DIN_PIN);
 93e:	9d 9a       	sbi	0x13, 5	; 19
	sbi(CS_DDR, CS_PIN);
 940:	6b 9a       	sbi	0x0d, 3	; 13
	cbi(DOUT_DDR, DOUT_PIN);
 942:	6d 98       	cbi	0x0d, 5	; 13
	cbi(IRQ_DDR, IRQ_PIN);
 944:	6c 98       	cbi	0x0d, 4	; 13
	
	//INT setup for INT4
	sbi(EIMSK, 4);
 946:	ec 9a       	sbi	0x1d, 4	; 29
	sbi(EICRB, 2);
 948:	ea e6       	ldi	r30, 0x6A	; 106
 94a:	f0 e0       	ldi	r31, 0x00	; 0
 94c:	80 81       	ld	r24, Z
 94e:	84 60       	ori	r24, 0x04	; 4
 950:	80 83       	st	Z, r24
	sei();
 952:	78 94       	sei
	
	position = Position(0,0);
 954:	19 82       	std	Y+1, r1	; 0x01
 956:	18 82       	st	Y, r1
 958:	1b 82       	std	Y+3, r1	; 0x03
 95a:	1a 82       	std	Y+2, r1	; 0x02
	
	sbi(CS_PORT,CS_PIN);
 95c:	73 9a       	sbi	0x0e, 3	; 14
	//sbi(CLK_PORT,CLK_PIN);
	//sbi(DIN_PORT,DIN_PIN);
	//sbi(IRQ_PORT,IRQ_PIN);
	_NOP();
 95e:	00 00       	nop
	_NOP();
 960:	00 00       	nop
	cbi(CS_PORT,CS_PIN);
 962:	73 98       	cbi	0x0e, 3	; 14
	_NOP();
 964:	00 00       	nop
	_NOP();
 966:	00 00       	nop
	WriteData(0x90);
 968:	60 e9       	ldi	r22, 0x90	; 144
 96a:	ce 01       	movw	r24, r28
 96c:	c4 df       	rcall	.-120    	; 0x8f6 <_ZN11TouchDriver9WriteDataEh>
	ClockPulse();
 96e:	ce 01       	movw	r24, r28
 970:	6f df       	rcall	.-290    	; 0x850 <_ZN11TouchDriver10ClockPulseEv>
	unsigned long temp_x = ReadData();
 972:	ce 01       	movw	r24, r28
 974:	7a df       	rcall	.-268    	; 0x86a <_ZN11TouchDriver8ReadDataEv>
 976:	73 9a       	sbi	0x0e, 3	; 14
	sbi(CS_PORT,CS_PIN);
 978:	df 91       	pop	r29
}
 97a:	cf 91       	pop	r28
 97c:	08 95       	ret

0000097e <_ZN11TouchDriver4ReadEv>:
 97e:	0f 93       	push	r16

void TouchDriver::Read()
{
 980:	1f 93       	push	r17
 982:	cf 93       	push	r28
 984:	df 93       	push	r29
 986:	ec 01       	movw	r28, r24
	unsigned int temp_x=0, temp_y=0;
	//int datacounter = 0;
	
	cbi(CS_PORT,CS_PIN);
 988:	73 98       	cbi	0x0e, 3	; 14
	
	//enables interrupt
	//cbi(IRQ_DDR, IRQ_PIN);
	if(!rbi(IRQ_PORT,IRQ_PIN))
 98a:	64 99       	sbic	0x0c, 4	; 12
 98c:	0d c0       	rjmp	.+26     	; 0x9a8 <_ZN11TouchDriver4ReadEv+0x2a>
	{
		WriteData(0x90);
 98e:	60 e9       	ldi	r22, 0x90	; 144
 990:	b2 df       	rcall	.-156    	; 0x8f6 <_ZN11TouchDriver9WriteDataEh>
		temp_y = ReadData();
 992:	ce 01       	movw	r24, r28
 994:	6a df       	rcall	.-300    	; 0x86a <_ZN11TouchDriver8ReadDataEv>
 996:	8c 01       	movw	r16, r24
		
		if(!rbi(IRQ_PORT,IRQ_PIN))
 998:	64 99       	sbic	0x0c, 4	; 12
 99a:	0b c0       	rjmp	.+22     	; 0x9b2 <_ZN11TouchDriver4ReadEv+0x34>
		{
			WriteData(0xD0);
 99c:	60 ed       	ldi	r22, 0xD0	; 208
 99e:	ce 01       	movw	r24, r28
			temp_x = ReadData();
 9a0:	aa df       	rcall	.-172    	; 0x8f6 <_ZN11TouchDriver9WriteDataEh>
 9a2:	ce 01       	movw	r24, r28
 9a4:	62 df       	rcall	.-316    	; 0x86a <_ZN11TouchDriver8ReadDataEv>
 9a6:	07 c0       	rjmp	.+14     	; 0x9b6 <_ZN11TouchDriver4ReadEv+0x38>
	sbi(CS_PORT,CS_PIN);
}

void TouchDriver::Read()
{
	unsigned int temp_x=0, temp_y=0;
 9a8:	00 e0       	ldi	r16, 0x00	; 0
 9aa:	10 e0       	ldi	r17, 0x00	; 0
 9ac:	80 e0       	ldi	r24, 0x00	; 0
 9ae:	90 e0       	ldi	r25, 0x00	; 0
 9b0:	02 c0       	rjmp	.+4      	; 0x9b6 <_ZN11TouchDriver4ReadEv+0x38>
 9b2:	80 e0       	ldi	r24, 0x00	; 0
 9b4:	90 e0       	ldi	r25, 0x00	; 0
		setY(y);
	}

	void setX(int x)
	{
		x_value=x;
 9b6:	99 83       	std	Y+1, r25	; 0x01
 9b8:	88 83       	st	Y, r24
	}
	void setY(int y)
	{
		y_value = y;
 9ba:	1b 83       	std	Y+3, r17	; 0x03
		}
	}
	position.setX(temp_x);
	position.setY(temp_y);
	//sbi(IRQ_DDR, IRQ_PIN);
	sbi(CS_PORT,CS_PIN);
 9bc:	0a 83       	std	Y+2, r16	; 0x02
	_NOP();
 9be:	73 9a       	sbi	0x0e, 3	; 14
	ClockPulse();
 9c0:	00 00       	nop
 9c2:	ce 01       	movw	r24, r28
 9c4:	45 df       	rcall	.-374    	; 0x850 <_ZN11TouchDriver10ClockPulseEv>
}
 9c6:	df 91       	pop	r29
 9c8:	cf 91       	pop	r28
 9ca:	1f 91       	pop	r17
 9cc:	0f 91       	pop	r16
 9ce:	08 95       	ret

000009d0 <_ZN8UIObjectC1EiiiiP5Color>:
{
	this->width = w;
}
void UIObject::SetColor(Color *color)
{
	this->color = color->getEncodedColor();
 9d0:	ef 92       	push	r14
 9d2:	ff 92       	push	r15
 9d4:	0f 93       	push	r16
 9d6:	1f 93       	push	r17
 9d8:	fc 01       	movw	r30, r24
 9da:	71 83       	std	Z+1, r23	; 0x01
 9dc:	60 83       	st	Z, r22
 9de:	53 83       	std	Z+3, r21	; 0x03
 9e0:	42 83       	std	Z+2, r20	; 0x02
 9e2:	35 83       	std	Z+5, r19	; 0x05
 9e4:	24 83       	std	Z+4, r18	; 0x04
 9e6:	17 83       	std	Z+7, r17	; 0x07
 9e8:	06 83       	std	Z+6, r16	; 0x06
 9ea:	d7 01       	movw	r26, r14
 9ec:	15 96       	adiw	r26, 0x05	; 5
 9ee:	8d 91       	ld	r24, X+
 9f0:	9c 91       	ld	r25, X
 9f2:	16 97       	sbiw	r26, 0x06	; 6
 9f4:	91 87       	std	Z+9, r25	; 0x09
 9f6:	80 87       	std	Z+8, r24	; 0x08
 9f8:	1f 91       	pop	r17
 9fa:	0f 91       	pop	r16
 9fc:	ff 90       	pop	r15
 9fe:	ef 90       	pop	r14
 a00:	08 95       	ret

00000a02 <_ZN8UIObjectC1Ev>:
 a02:	fc 01       	movw	r30, r24
 a04:	11 82       	std	Z+1, r1	; 0x01
 a06:	10 82       	st	Z, r1
 a08:	13 82       	std	Z+3, r1	; 0x03
 a0a:	12 82       	std	Z+2, r1	; 0x02
 a0c:	15 82       	std	Z+5, r1	; 0x05
 a0e:	14 82       	std	Z+4, r1	; 0x04
 a10:	17 82       	std	Z+7, r1	; 0x07
 a12:	16 82       	std	Z+6, r1	; 0x06
 a14:	11 86       	std	Z+9, r1	; 0x09
 a16:	10 86       	std	Z+8, r1	; 0x08
 a18:	08 95       	ret

00000a1a <_ZN8UIObject9GetHeightEv>:
}

int UIObject::GetHeight()
{
	return this->height;
}
 a1a:	fc 01       	movw	r30, r24
 a1c:	84 81       	ldd	r24, Z+4	; 0x04
 a1e:	95 81       	ldd	r25, Z+5	; 0x05
 a20:	08 95       	ret

00000a22 <_ZN8UIObject9GetStartXEv>:

int UIObject::GetStartX()
{
	return this->startX;
}
 a22:	fc 01       	movw	r30, r24
 a24:	80 81       	ld	r24, Z
 a26:	91 81       	ldd	r25, Z+1	; 0x01
 a28:	08 95       	ret

00000a2a <_ZN8UIObject9GetStartYEv>:

int UIObject::GetStartY()
{
	return this->startY;
}
 a2a:	fc 01       	movw	r30, r24
 a2c:	82 81       	ldd	r24, Z+2	; 0x02
 a2e:	93 81       	ldd	r25, Z+3	; 0x03
 a30:	08 95       	ret

00000a32 <_ZN8UIObject8GetWidthEv>:

int UIObject::GetWidth()
{
	return this->width;
}
 a32:	fc 01       	movw	r30, r24
 a34:	86 81       	ldd	r24, Z+6	; 0x06
 a36:	97 81       	ldd	r25, Z+7	; 0x07
 a38:	08 95       	ret

00000a3a <_ZN8UIObject8GetColorEv>:

unsigned int UIObject::GetColor()
{
	return this->color;
}
 a3a:	fc 01       	movw	r30, r24
 a3c:	80 85       	ldd	r24, Z+8	; 0x08
 a3e:	91 85       	ldd	r25, Z+9	; 0x09
 a40:	08 95       	ret

00000a42 <_ZN15UIObjectFactoryC1Ev>:
 *  Author: math0
 */ 

#include "UIObjectFactory.h"

UIObjectFactory::UIObjectFactory()
 a42:	df cf       	rjmp	.-66     	; 0xa02 <_ZN8UIObjectC1Ev>
 a44:	08 95       	ret

00000a46 <__divmodhi4>:
 a46:	97 fb       	bst	r25, 7
 a48:	07 2e       	mov	r0, r23
 a4a:	16 f4       	brtc	.+4      	; 0xa50 <__divmodhi4+0xa>
 a4c:	00 94       	com	r0
 a4e:	06 d0       	rcall	.+12     	; 0xa5c <__divmodhi4_neg1>
 a50:	77 fd       	sbrc	r23, 7
 a52:	08 d0       	rcall	.+16     	; 0xa64 <__divmodhi4_neg2>
 a54:	26 d0       	rcall	.+76     	; 0xaa2 <__udivmodhi4>
 a56:	07 fc       	sbrc	r0, 7
 a58:	05 d0       	rcall	.+10     	; 0xa64 <__divmodhi4_neg2>
 a5a:	3e f4       	brtc	.+14     	; 0xa6a <__divmodhi4_exit>

00000a5c <__divmodhi4_neg1>:
 a5c:	90 95       	com	r25
 a5e:	81 95       	neg	r24
 a60:	9f 4f       	sbci	r25, 0xFF	; 255
 a62:	08 95       	ret

00000a64 <__divmodhi4_neg2>:
 a64:	70 95       	com	r23
 a66:	61 95       	neg	r22
 a68:	7f 4f       	sbci	r23, 0xFF	; 255

00000a6a <__divmodhi4_exit>:
 a6a:	08 95       	ret

00000a6c <__mulhisi3>:
 a6c:	05 d0       	rcall	.+10     	; 0xa78 <__umulhisi3>
 a6e:	33 23       	and	r19, r19
 a70:	12 f4       	brpl	.+4      	; 0xa76 <__mulhisi3+0xa>
 a72:	8a 1b       	sub	r24, r26
 a74:	9b 0b       	sbc	r25, r27
 a76:	10 c0       	rjmp	.+32     	; 0xa98 <__usmulhisi3_tail>

00000a78 <__umulhisi3>:
 a78:	a2 9f       	mul	r26, r18
 a7a:	b0 01       	movw	r22, r0
 a7c:	b3 9f       	mul	r27, r19
 a7e:	c0 01       	movw	r24, r0
 a80:	a3 9f       	mul	r26, r19
 a82:	70 0d       	add	r23, r0
 a84:	81 1d       	adc	r24, r1
 a86:	11 24       	eor	r1, r1
 a88:	91 1d       	adc	r25, r1
 a8a:	b2 9f       	mul	r27, r18
 a8c:	70 0d       	add	r23, r0
 a8e:	81 1d       	adc	r24, r1
 a90:	11 24       	eor	r1, r1
 a92:	91 1d       	adc	r25, r1
 a94:	08 95       	ret

00000a96 <__usmulhisi3>:
 a96:	f0 df       	rcall	.-32     	; 0xa78 <__umulhisi3>

00000a98 <__usmulhisi3_tail>:
 a98:	b7 ff       	sbrs	r27, 7
 a9a:	08 95       	ret
 a9c:	82 1b       	sub	r24, r18
 a9e:	93 0b       	sbc	r25, r19
 aa0:	08 95       	ret

00000aa2 <__udivmodhi4>:
 aa2:	aa 1b       	sub	r26, r26
 aa4:	bb 1b       	sub	r27, r27
 aa6:	51 e1       	ldi	r21, 0x11	; 17
 aa8:	07 c0       	rjmp	.+14     	; 0xab8 <__udivmodhi4_ep>

00000aaa <__udivmodhi4_loop>:
 aaa:	aa 1f       	adc	r26, r26
 aac:	bb 1f       	adc	r27, r27
 aae:	a6 17       	cp	r26, r22
 ab0:	b7 07       	cpc	r27, r23
 ab2:	10 f0       	brcs	.+4      	; 0xab8 <__udivmodhi4_ep>
 ab4:	a6 1b       	sub	r26, r22
 ab6:	b7 0b       	sbc	r27, r23

00000ab8 <__udivmodhi4_ep>:
 ab8:	88 1f       	adc	r24, r24
 aba:	99 1f       	adc	r25, r25
 abc:	5a 95       	dec	r21
 abe:	a9 f7       	brne	.-22     	; 0xaaa <__udivmodhi4_loop>
 ac0:	80 95       	com	r24
 ac2:	90 95       	com	r25
 ac4:	bc 01       	movw	r22, r24
 ac6:	cd 01       	movw	r24, r26
 ac8:	08 95       	ret

00000aca <__tablejump2__>:
 aca:	ee 0f       	add	r30, r30
 acc:	ff 1f       	adc	r31, r31
 ace:	88 1f       	adc	r24, r24
 ad0:	8b bf       	out	0x3b, r24	; 59
 ad2:	07 90       	elpm	r0, Z+
 ad4:	f6 91       	elpm	r31, Z
 ad6:	e0 2d       	mov	r30, r0
 ad8:	19 94       	eijmp

00000ada <__itoa_ncheck>:
 ada:	bb 27       	eor	r27, r27
 adc:	4a 30       	cpi	r20, 0x0A	; 10
 ade:	31 f4       	brne	.+12     	; 0xaec <__itoa_ncheck+0x12>
 ae0:	99 23       	and	r25, r25
 ae2:	22 f4       	brpl	.+8      	; 0xaec <__itoa_ncheck+0x12>
 ae4:	bd e2       	ldi	r27, 0x2D	; 45
 ae6:	90 95       	com	r25
 ae8:	81 95       	neg	r24
 aea:	9f 4f       	sbci	r25, 0xFF	; 255
 aec:	01 c0       	rjmp	.+2      	; 0xaf0 <__utoa_common>

00000aee <__utoa_ncheck>:
 aee:	bb 27       	eor	r27, r27

00000af0 <__utoa_common>:
 af0:	fb 01       	movw	r30, r22
 af2:	55 27       	eor	r21, r21
 af4:	aa 27       	eor	r26, r26
 af6:	88 0f       	add	r24, r24
 af8:	99 1f       	adc	r25, r25
 afa:	aa 1f       	adc	r26, r26
 afc:	a4 17       	cp	r26, r20
 afe:	10 f0       	brcs	.+4      	; 0xb04 <__utoa_common+0x14>
 b00:	a4 1b       	sub	r26, r20
 b02:	83 95       	inc	r24
 b04:	50 51       	subi	r21, 0x10	; 16
 b06:	b9 f7       	brne	.-18     	; 0xaf6 <__utoa_common+0x6>
 b08:	a0 5d       	subi	r26, 0xD0	; 208
 b0a:	aa 33       	cpi	r26, 0x3A	; 58
 b0c:	08 f0       	brcs	.+2      	; 0xb10 <__utoa_common+0x20>
 b0e:	a9 5d       	subi	r26, 0xD9	; 217
 b10:	a1 93       	st	Z+, r26
 b12:	00 97       	sbiw	r24, 0x00	; 0
 b14:	79 f7       	brne	.-34     	; 0xaf4 <__utoa_common+0x4>
 b16:	b1 11       	cpse	r27, r1
 b18:	b1 93       	st	Z+, r27
 b1a:	11 92       	st	Z+, r1
 b1c:	cb 01       	movw	r24, r22
 b1e:	00 c0       	rjmp	.+0      	; 0xb20 <strrev>

00000b20 <strrev>:
 b20:	dc 01       	movw	r26, r24
 b22:	fc 01       	movw	r30, r24
 b24:	67 2f       	mov	r22, r23
 b26:	71 91       	ld	r23, Z+
 b28:	77 23       	and	r23, r23
 b2a:	e1 f7       	brne	.-8      	; 0xb24 <strrev+0x4>
 b2c:	32 97       	sbiw	r30, 0x02	; 2
 b2e:	04 c0       	rjmp	.+8      	; 0xb38 <strrev+0x18>
 b30:	7c 91       	ld	r23, X
 b32:	6d 93       	st	X+, r22
 b34:	70 83       	st	Z, r23
 b36:	62 91       	ld	r22, -Z
 b38:	ae 17       	cp	r26, r30
 b3a:	bf 07       	cpc	r27, r31
 b3c:	c8 f3       	brcs	.-14     	; 0xb30 <strrev+0x10>
 b3e:	08 95       	ret

00000b40 <_exit>:
 b40:	f8 94       	cli

00000b42 <__stop_program>:
 b42:	ff cf       	rjmp	.-2      	; 0xb42 <__stop_program>
